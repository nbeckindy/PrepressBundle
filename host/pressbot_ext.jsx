//----- POLYFILLS -----////Array & function polyfills, pulled from developer.mozilla.orgif (!Array.prototype.indexOf) {  Array.prototype.indexOf = function(searchElement, fromIndex) {    var k;    // 1. Let O be the result of calling ToObject passing    //    the this value as the argument.    if (this == null) {      throw new TypeError('"this" is null or not defined');    }    var O = Object(this);    // 2. Let lenValue be the result of calling the Get    //    internal method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If len is 0, return -1.    if (len === 0) {      return -1;    }    // 5. If argument fromIndex was passed let n be    //    ToInteger(fromIndex); else let n be 0.    var n = +fromIndex || 0;    if (Math.abs(n) === Infinity) {      n = 0;    }    // 6. If n >= len, return -1.    if (n >= len) {      return -1;    }    // 7. If n >= 0, then Let k be n.    // 8. Else, n<0, Let k be len - abs(n).    //    If k is less than 0, then let k be 0.    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);    // 9. Repeat, while k < len    while (k < len) {      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the      //    HasProperty internal method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      //    i.  Let elementK be the result of calling the Get      //        internal method of O with the argument ToString(k).      //   ii.  Let same be the result of applying the      //        Strict Equality Comparison Algorithm to      //        searchElement and elementK.      //  iii.  If same is true, return k.      if (k in O && O[k] === searchElement) {        return k;      }      k++;    }    return -1;  };}if (!Array.prototype.every) {  Array.prototype.every = function(callbackfn, thisArg) {    'use strict';    var T, k;    if (this == null) {      throw new TypeError('this is null or not defined');    }    // 1. Let O be the result of calling ToObject passing the this    //    value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get internal method    //    of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.    if (typeof callbackfn !== 'function') {      throw new TypeError();    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length > 1) {      T = thisArg;    }    // 6. Let k be 0.    k = 0;    // 7. Repeat, while k < len    while (k < len) {      var kValue;      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty internal      //    method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal method        //    of O with argument Pk.        kValue = O[k];        // ii. Let testResult be the result of calling the Call internal method        //     of callbackfn with T as the this value and argument list        //     containing kValue, k, and O.        var testResult = callbackfn.call(T, kValue, k, O);        // iii. If ToBoolean(testResult) is false, return false.        if (!testResult) {          return false;        }      }      k++;    }    return true;  };}if (!Array.prototype.some) {  Array.prototype.some = function(fun /*, thisArg*/) {    'use strict';    if (this == null) {      throw new TypeError('Array.prototype.some called on null or undefined');    }    if (typeof fun !== 'function') {      throw new TypeError();    }    var t = Object(this);    var len = t.length >>> 0;    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;    for (var i = 0; i < len; i++) {      if (i in t && fun.call(thisArg, t[i], i, t)) {        return true;      }    }    return false;  };}if (!Array.prototype.map) {  Array.prototype.map = function(callback, thisArg) {    var T, A, k;    if (this == null) {      throw new TypeError(' this is null or not defined');    }    // 1. Let O be the result of calling ToObject passing the |this|    //    value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get internal    //    method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If IsCallable(callback) is false, throw a TypeError exception.    // See: http://es5.github.com/#x9.11    if (typeof callback !== 'function') {      throw new TypeError(callback + ' is not a function');    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length > 1) {      T = thisArg;    }    // 6. Let A be a new array created as if by the expression new Array(len)    //    where Array is the standard built-in constructor with that name and    //    len is the value of len.    A = new Array(len);    // 7. Let k be 0    k = 0;    // 8. Repeat, while k < len    while (k < len) {      var kValue, mappedValue;      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty internal      //    method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal        //    method of O with argument Pk.        kValue = O[k];        // ii. Let mappedValue be the result of calling the Call internal        //     method of callback with T as the this value and argument        //     list containing kValue, k, and O.        mappedValue = callback.call(T, kValue, k, O);        // iii. Call the DefineOwnProperty internal method of A with arguments        // Pk, Property Descriptor        // { Value: mappedValue,        //   Writable: true,        //   Enumerable: true,        //   Configurable: true },        // and false.        // In browsers that support Object.defineProperty, use the following:        // Object.defineProperty(A, k, {        //   value: mappedValue,        //   writable: true,        //   enumerable: true,        //   configurable: true        // });        // For best browser support, use the following:        A[k] = mappedValue;      }      // d. Increase k by 1.      k++;    }    // 9. return A    return A;  };}if (!Array.prototype.reduce) {  Array.prototype.reduce = function(callback /*, initialValue*/) {    'use strict';    if (this == null) {      throw new TypeError('Array.prototype.reduce called on null or undefined');    }    if (typeof callback !== 'function') {      throw new TypeError(callback + ' is not a function');    }    var t = Object(this), len = t.length >>> 0, k = 0, value;    if (arguments.length == 2) {      value = arguments[1];    } else {      while (k < len && ! k in t) {        k++;      }      if (k >= len) {        throw new TypeError('Reduce of empty array with no initial value');      }      value = t[k++];    }    for (; k < len; k++) {      if (k in t) {        value = callback(value, t[k], k, t);      }    }    return value;  };}if (!Function.prototype.bind) {  Function.prototype.bind = function(oThis) {    if (typeof this !== 'function') {      // closest thing possible to the ECMAScript 5      // internal IsCallable function      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');    }    var aArgs   = Array.prototype.slice.call(arguments, 1),        fToBind = this,        fNOP    = function() {},        fBound  = function() {          return fToBind.apply(this instanceof fNOP && oThis                 ? this                 : oThis,                 aArgs.concat(Array.prototype.slice.call(arguments)));        };    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;  };}//----- OBJECT CONSTRUCTORS W/PROPERTIES -----////LineItem object constructor - this object holds all finishing information for each line item.function LineItem(path, name, quantity, nesting, finishedHeight, finishedWidth, cutOffset, useDocumentArtboard, grommetStatus, grommetSpacing, grommetByNumber, pocketStatus, pocketSize, rotation, tab, artworkObject) {    this.path = path;    this.name = name;    this.quantity = quantity;    this.nesting = nesting; //"Yes" or "No"    this.finishedHeight = finishedHeight;    this.finishedWidth = finishedWidth;    this.cutOffset = cutOffset; //array [top, bottom, left, right]    this.useDocumentArtboard = useDocumentArtboard;    this.grommetStatus = grommetStatus; //boolean    this.grommetSpacing = grommetSpacing; //array [top, bottom, left, right]    this.grommetByNumber = grommetByNumber; //array to determine if grommets are placed by number(=1) or distance(=0), array in order of [horizontal, vertical]    this.pocketStatus = pocketStatus; //boolean    this.pocketSize = pocketSize; //array [top, bottom, left, right]    this.rotation = rotation;    this.tab = tab;    this.artworkObject = artworkObject; //Artwork object for this line item}//Artwork object constructor - this object references the actual artwork for the line item. Instances of these objects are created in prepFiles()function Artwork(name, artGroup, artLayer, cutPath, cutPathOffset, cutLayer, kissCutPath, kissCutPathOffset, kissCutLayer, artboardPath, artboardOffset, opacityMasksPresent) {    this.name = name;    this.artGroup = artGroup;    this.artLayer = artLayer;    this.cutPath = cutPath;    this.cutPathOffset = cutPathOffset; //array for cut path offset [top, left]    this.cutLayer = cutLayer;    this.kissCutPath = kissCutPath;    this.kissCutPathOffset = kissCutPathOffset; //array for cut path offset [top, left]    this.kissCutLayer = kissCutLayer;    this.artboardPath = artboardPath;    this.artboardOffset = artboardOffset;    this.opacityMasksPresent = opacityMasksPresent;}//PrintSettings object constructor - this object holds information which applies to all line itemsfunction PrintSettings(source, scale, regMarkSpacing, zundCut, materialWidth, materialHeight, rigid, perimPadding, save, closeSource, perimStroke){    this.source = source; //info from source panel, one of "active", "all", or "external"    this.scale = scale;    this.regMarkSpacing = regMarkSpacing;    this.zundCut = zundCut; //boolean - set up for Zund?    this.materialWidth = materialWidth;    this.materialHeight = materialHeight;    this.rigid = rigid; //boolean - is print material rigid?    this.perimPadding = perimPadding;    this.save = save; //boolean - will files be saved?    this.closeSource = closeSource; //boolean - close source files when finished?    this.perimStroke = perimStroke; //boolean - 1 pixel perimeter stroke?}//----- OBJECT METHODS -----///*    LineItem.prototype.cropArtboard( targetDocument, settings )        Applies each LineItem's cutOffset property to the artboard size, shrinking or expanding it.     This occurs first before any other finishing is applied, so cut paths, grommet locations,    etc will all be based on the new artboard size.    (This used to use finishedHeight and finishedWidth to adjust the size, which is currently commented out.)        @param targetDocument       The open document for this particular line item.    @param settings             Current PrintSettings object (just for scale).    */LineItem.prototype.cropArtboard = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    //Set scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //var heightDiff = 0, widthDiff = 0;    //----- MATHS -----//        //If finishedHeight & finishedWidth is > 0, determine difference between targetDocument height & width and lineItem height & width    /*if(this.finishedHeight > 0 && this.finishedWidth > 0){        //Determine difference between finished size and artboard size        if(targetDocument.height != this.finishedHeight){            var heightDiff = (targetDocument.height - (this.finishedHeight * inchScalePixels))/2;        }        if(targetDocument.width != this.finishedWidth){            var widthDiff = (targetDocument.width - (this.finishedWidth * inchScalePixels))/2;        }    }    //If finishedHeight & finishedWidth is <= 0, reduce artboard size by that amount    if(this.finishedHeight <= 0 && this.finishedWidth <= 0){        var heightDiff = Math.abs(this.finishedHeight * inchScalePixels);        var widthDiff = Math.abs(this.finishedWidth * inchScalePixels);    }    //If cutOffset is <= 0, reduce artboard size by that amount    if(this.cutOffset <= 0){        heightDiff = Math.abs(this.cutOffset * inchScalePixels);        widthDiff = heightDiff;    }*/    //----- DO STUFF -----//    //Adjust artboard according to cutOffset sizes    targetArtboard.artboardRect = [        targetArtboard.artboardRect[0] - this.cutOffset[2] * inchScalePixels, //left        targetArtboard.artboardRect[1] + this.cutOffset[0] * inchScalePixels, //top        targetArtboard.artboardRect[2] + this.cutOffset[3] * inchScalePixels, //right        targetArtboard.artboardRect[3] - this.cutOffset[1] * inchScalePixels //bottom    ];      //targetArtboard = null;};/*    LineItem.prototype.placeGrommets        Places grommet marks around the perimeter based on the LineItem's grommet properties.     First it uses the pocketSize property to determine how far from the edge of the     artboard the grommets should be placed. It then, for each side, uses the file's scale     to calculate the quantity of grommets for each side and the distance in points between     them, based on the input from the user (by number or by distance) and the available space.     Finally it places ellipse objects as grommets on each side.            @param targetDocument       The open document for this particular line item.    @param settings             Current PrintSettings object (just for scale).    */LineItem.prototype.placeGrommets = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    var targetLayer = targetDocument.layers.getByName("Layer 1");    //Set scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //Individual grommet    var grommet;    //Create group for grommets    var grommetGroup = targetLayer.groupItems.add();    grommetGroup.name = "Grommets";    //Array to calculate grommet this.grommetSpacing according to scale, same indexes as this.grommetSpacing    var spacingPixels = [];    spacingPixels.length = 4;    //Array to calculate grommet distances, follows same indexes as fileObject.grommetSpacing    var grommetDistanceFromEdge = [];    grommetDistanceFromEdge.length = 4;    //Array to calculate grommet distance according to scale, same indexes as distanceFromEdge    var distanceFromEdgePixels = [];    distanceFromEdgePixels.length = 4;    //Grommet size of 1/8"    var grommetRadius  = inchScalePixels / 8;    //Grommet quantity array index: 0 = top, 1 = bottom, 2 = left, 3 = right;    var grommetNum = [];    grommetNum.length = 4;    //Grommet actual this.grommetSpacing, same index - this variable stores pixels needed to actually place the grommets evenly    var actualSpacing = [];    actualSpacing.length = 4;    //----- MATHS -----//    //For grommets on each side, determine the distance from the edge    for(var i=0;i<4;i++){        if (this.pocketSize[i] > 0 && this.pocketSize[i] < 1) {            grommetDistanceFromEdge[i] = this.pocketSize[i];        } else if (this.pocketSize[i] >= 1 && this.pocketSize[i] <= 2 || this.pocketSize[i] == 0) {            grommetDistanceFromEdge[i] = 1;        } else if (this.pocketSize[i] > 2) {            grommetDistanceFromEdge[i] = this.pocketSize[i] - 0.5;        }        //Set grommet spacing and distance according to scale        spacingPixels[i] = this.grommetSpacing[i] * inchScalePixels;        distanceFromEdgePixels[i] = grommetDistanceFromEdge[i] * inchScalePixels;    }    //----- DO STUFF -----//    //Determine actual grommet placement & place them onto file    for(var i = 0; i < grommetNum.length; i++){        //----- MORE MATHS -----//        //Calculate actual grommet this.grommetSpacing in pixels        switch (i) {        //Top & bottom        case 0:        case 1:            //If user entered invalid numbers (too small or too large), avoid running math that would divide by 0            if (spacingPixels[i] <= 0 || (spacingPixels[i] > targetDocument.width && this.grommetByNumber[0] == 0)){                grommetNum[i] = 0;                actualSpacing[i] = 0;            } else {                //If user selected grommets by distance, determine number of grommets                if (this.grommetByNumber[0] == 0){                    grommetNum[i] = Math.round((targetDocument.width - (distanceFromEdgePixels[2] + distanceFromEdgePixels[3]))/(spacingPixels[i])) + 1;                //If user specified number of grommets, directly plug that number into the grommetNum variable                } else if (this.grommetByNumber[0] == 1){                    grommetNum[i] = this.grommetSpacing[i];                }                //Avoid dividing by invalid numbers                if (grommetNum[i] <= 1){                    actualSpacing[i] = 0;                } else {                    //Get the actual this.grommetSpacing needed between top & bottom grommets for this particular banner                    actualSpacing[i] = (targetDocument.width - (distanceFromEdgePixels[2] + distanceFromEdgePixels[3])) / (grommetNum[i] - 1);                }            }            break;        //Left & right        //This is the same math as top and bottom, but using different grommetByNumber and distanceFromEdge variables        case 2:        case 3:            if (spacingPixels[i] <= 0 || (spacingPixels[i] > targetDocument.height && this.grommetByNumber[1] == 0)){                grommetNum[i] = 0;                actualSpacing[i] = 0;            } else {                if (this.grommetByNumber[1] == 0){                    grommetNum[i] = Math.round((targetDocument.height - (distanceFromEdgePixels[0] + distanceFromEdgePixels[1]))/(spacingPixels[i])) + 1;                } else if (this.grommetByNumber[1] == 1){                    grommetNum[i] = this.grommetSpacing[i];                }                if (grommetNum[i] <= 1){                    actualSpacing[i] = 0;                } else {                    actualSpacing[i] = (targetDocument.height - (distanceFromEdgePixels[0] + distanceFromEdgePixels[1])) / (grommetNum[i] - 1);                }            }            break;        }        //----- DO STUFF WITH MATHS -----//        //For each side, loop according to number of grommets on the side        for (var x = 0; x < grommetNum[i]; x++){            switch (i) {                //Place grommets along the top (x pos, y pos, height, width)                //Starting at top left corner                case 0:                grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[1] - (distanceFromEdgePixels[0] - (inchScalePixels/16)),                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[2] - (inchScalePixels/16)) + (actualSpacing[0]*x),                    grommetRadius, grommetRadius);                break;                //Place grommets along the bottom                //Starting at bottom left corner                case 1:                grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[1] + (inchScalePixels/16)),                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[2] - (inchScalePixels/16)) + (actualSpacing[1]*x),                    grommetRadius, grommetRadius);                break;                //Place grommets along the left                //Starting at bottom left corner                case 2:                grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[1] + (inchScalePixels/16)) + (actualSpacing[2]*x),                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[2] - (inchScalePixels/16)),                    grommetRadius, grommetRadius);                break;                //Place grommets along the right                //Starting at bottom right corner                case 3:                grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[1] + (inchScalePixels/16)) + (actualSpacing[3]*x),                    targetArtboard.artboardRect[2] - (distanceFromEdgePixels[3] + (inchScalePixels/16)),                    grommetRadius, grommetRadius);                break;            }            //Set appearance of each grommet            grommet.filled = true;            grommet.stroked = false;            grommet.fillColor = CMYKYellow;            grommet.fillColor.yellow = 50;            //Add each grommet to the group            grommet.move(grommetGroup, ElementPlacement.PLACEATEND);        }    }    //targetArtboard = targetLayer = grommetGroup = grommet = null;};/*    LineItem.prototype.createPockets        Creates pockets by expanding the artboard size according to the LineItem's pocketSize    property. It then places a 1 pixel black border around the perimeter of the artboard,    Finally it adds a job number (taken from the LineItem's name property) in the top and     bottom pockets, if they are present.        @param targetDocument       The open document for this particular line item.    @param settings             Current PrintSettings object (just for scale).*/LineItem.prototype.createPockets = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    var targetLayer = targetDocument.layers.getByName("Layer 1");    //Don't make pockets if all pocket sizes are < 0    var pocketsTrue = false;    //Array to store pocket size according to scale, follows same indices as fileObject.pocketSize    var pocketSizePixels = [];    pocketSizePixels.length = 4;    //Scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //----- MATHS -----//    //Set pocket size according to scale    for(var i=0;i<4;i++){        pocketSizePixels[i] = this.pocketSize[i] * inchScalePixels;        if(pocketSizePixels[i] > 0) pocketsTrue = true;    }    //----- DO STUFF -----//    if(pocketsTrue){        //Make artboard bigger in all directions, according to pocket size given        targetArtboard.artboardRect = [            targetArtboard.artboardRect[0] - pocketSizePixels[2],            targetArtboard.artboardRect[1] + pocketSizePixels[0],            targetArtboard.artboardRect[2] + pocketSizePixels[3],            targetArtboard.artboardRect[3] - pocketSizePixels[1]        ];                //Create black rectangle stroke around perimeter of document size (x pos, y pos, width, height)        var pocketRect = targetLayer.pathItems.rectangle(            targetArtboard.artboardRect[1],            targetArtboard.artboardRect[0],            targetDocument.width, targetDocument.height );        pocketRect.filled = false;        pocketRect.strokeColor = CMYKBlack;        pocketRect.strokeWidth = inchScalePixels / 72;        pocketRect.move( targetDocument, ElementPlacement.PLACEATEND);        //Create Job number in top left and bottom right corners        if(pocketSizePixels[0] > 0){            var pocketLabel = targetLayer.textFrames.add();            var pocketLabelBottom;            pocketLabel.contents = this.name;            pocketLabel.textRange.characterAttributes.size = inchScalePixels / 2;            pocketLabel.textRange.characterAttributes.fillColor = CMYKYellow;            pocketLabel.textRange.characterAttributes.textFont = textFonts["MyriadPro-Bold"];            pocketLabel.textRange.paragraphAttributes.justification = Justification.LEFT;            pocketLabel.rotate(180);            pocketLabel.move( targetDocument, ElementPlacement.PLACEATEND);            if(pocketSizePixels[1] > 0) pocketLabelBottom = pocketLabel.duplicate( targetDocument, ElementPlacement.PLACEATEND);            pocketLabel.textRange.paragraphAttributes.justification = Justification.RIGHT;            pocketLabel.position = [ pocketSizePixels[2] > 0 ? pocketSizePixels[2] + (inchScalePixels*2) : inchScalePixels*2, targetArtboard.artboardRect[1] - (inchScalePixels*0.125) ];            if(pocketSizePixels[1] > 0){                //pocketLabelBottom.rotate(180);                pocketLabelBottom.position = [targetDocument.width - pocketLabelBottom.width - (pocketSizePixels[3] > 0 ? (pocketSizePixels[3]*3 + (inchScalePixels*4)) : inchScalePixels*4), (targetArtboard.artboardRect[1] - targetDocument.height) + (inchScalePixels/1.5)];                pocketLabelBottom.textRange.paragraphAttributes.justification = Justification.RIGHT;            }        }    }    //targetArtboard = targetLayer = pocketRect = null;};//Save target documentLineItem.prototype.saveOut = function( targetDocument, settings ){    //----- VARIABLE DECLARATIONS -----//    //Scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //Set PDF settings    var saveOptions = new PDFSaveOptions();    saveOptions.pDFPreset = 'Indy Imaging PDF 01_13';    //Set layers    var targetLayerOne = targetDocument.layers.getByName("Layer 1");    var jobLabel = targetDocument.layers.getByName("Job#").textFrames[0].contents;    //Add underscore to jobLabel if it ends in a word character (in tiles, for example)    //Or if the job will get a scale label, also add an underscore    if(jobLabel.search("up") != -1 || jobLabel.search(/-\d+\w+/) != -1 || inchScalePixels<72) jobLabel += "_";    var printLabel = "", scaleLabel = ""; //More filename labels    if(settings.zundCut == true) printLabel = "print";    if(inchScalePixels<72){        scaleLabel = "scale_";    }    var targetThruCut, targetKissCut; //Layers to get cut paths from    //Set cut layer variables, then hide layers    for (var i = 0; i < targetDocument.layers.length; i++){        if (targetDocument.layers[i].name == "Thru-cut"){            targetThruCut = targetDocument.layers.getByName("Thru-cut");            targetThruCut.visible = false;        }        if (targetDocument.layers[i].name == "Kiss-cut"){            targetKissCut = targetDocument.layers.getByName("Kiss-cut");            targetKissCut.visible = false;        }    }    var destFolderPrint, destFolderCut; //Destination folders    //----- DO STUFF -----//    //Make destination path same as existing path    if(jobLabel){        destFolderPrint = new Folder(this.path + "/" + jobLabel + scaleLabel + printLabel + ".pdf");        destFolderCut = new Folder(this.path + "/" + jobLabel + scaleLabel + "cut.pdf");    } else {        destFolderPrint = new Folder(this.path + "/" + this.name + scaleLabel + printLabel + ".pdf");        destFolderCut = new Folder(this.path + "/" + this.name + scaleLabel + "cut.pdf");    }    var saveFile = destFolderPrint.saveDlg("Save print file");    if (saveFile) {        //If Zund is active, save both print and cut files - if not, save print file only        if (settings.zundCut == true){            targetDocument.saveAs(saveFile, saveOptions);            //Make cut layer visible and delete bottom later            targetThruCut.visible = true;            if(targetKissCut) targetKissCut.visible = true;            targetLayerOne.remove();            //Outline all text in document            for (var i = targetDocument.textFrames.length - 1; i > -1; i--){                targetDocument.textFrames[i].createOutline();            }            //Save cut file            saveFile = destFolderCut.saveDlg("Save cut file");            if (saveFile) targetDocument.saveAs(saveFile, saveOptions);        } else {            targetDocument.saveAs(saveFile, saveOptions);        }    }    //targetLayerOne = jobLabel = targetThruCut = targetKissCut = saveFile = null;};//Rotate all artwork in fileArtwork.prototype.rotateArt = function( targetDocument ){    //----- DECLARE VARIABLES WITH MATHS -----//    var targetArtboard = targetDocument.artboards[0];    //var artboardOffsetTop = this.artGroup.top - targetArtboard.artboardRect[1];    //var artboardOffsetLeft = this.artGroup.left - targetArtboard.artboardRect[0];    var strokeDifference = (this.artGroup.visibleBounds[1] - this.artGroup.geometricBounds[1]) * 2;    //var rotationOpacityMasks = [];    //----- DO STUFF -----//    //Rotate artwork group    this.artGroup.rotate(-90);    //Rotate artboard    this.artboardPath.rotate(-90);    this.artboardPath.top = this.artGroup.top + this.artboardOffset[1];    this.artboardPath.left = this.artGroup.left + (this.artGroup.width - this.artboardPath.width + strokeDifference) - this.artboardOffset[0];    targetArtboard.artboardRect = [        this.artboardPath.geometricBounds[0],        this.artboardPath.geometricBounds[1],        this.artboardPath.geometricBounds[2],        this.artboardPath.geometricBounds[3]    ];    this.artboardOffset = [this.artGroup.top - this.artboardPath.top, this.artGroup.left - this.artboardPath.left];    //Rotate cut path group if property is defined, adjust cut path offset for copying to print file    if(this.cutPath){        this.cutPath.rotate(-90);        this.cutPath.top = this.artGroup.top + this.cutPathOffset[1];        this.cutPath.left = this.artGroup.left + (this.artGroup.width - this.cutPath.width) - this.cutPathOffset[0];        this.cutPathOffset = [this.artGroup.top - this.cutPath.top, this.artGroup.left - this.cutPath.left];    }    if(this.kissCutPath){        this.kissCutPath.rotate(-90);        this.kissCutPath.top = this.artGroup.top + this.kissCutPathOffset[1];        this.kissCutPath.left = this.artGroup.left + (this.artGroup.width - this.kissCutPath.width) - this.kissCutPathOffset[0];        this.kissCutPathOffset = [this.artGroup.top - this.kissCutPath.top, this.artGroup.left - this.kissCutPath.left];    }    //targetArtboard = null;};//----- GLOBAL VARIABLES -----////Set script directoryvar scriptPath = $.fileName.split("/");var scriptDir = scriptPath.slice(0, -1).join("/");//Set Blackvar CMYKBlack = new CMYKColor();CMYKBlack.black = 100;CMYKBlack.cyan = 0;CMYKBlack.magenta = 0;CMYKBlack.yellow = 0;//Set Yellowvar CMYKYellow = new CMYKColor();CMYKYellow.black = 0;CMYKYellow.cyan = 0;CMYKYellow.magenta = 0;CMYKYellow.yellow = 100;//Set Thru-cut colorvar CMYKThruCut = new CMYKColor();CMYKThruCut.black = 1;CMYKThruCut.cyan = 100;CMYKThruCut.magenta = 1;CMYKThruCut.yellow = 1;//Set Kiss-cut colorvar CMYKKissCut = new CMYKColor();CMYKKissCut.black = 1;CMYKKissCut.cyan = 1;CMYKKissCut.magenta = 100;CMYKKissCut.yellow = 1;//Set Regmarks colorvar CMYKRegmarks = new CMYKColor();CMYKRegmarks.black = 100;CMYKRegmarks.cyan = 31;CMYKRegmarks.magenta = 31;CMYKRegmarks.yellow = 31;//Document presets to be used if Basic CMYK is not availablevar docPresets = new DocumentPreset();docPresets.units = RulerUnits.Inches;var debug = false;//Set up XMP API for adding metadataif (ExternalObject.AdobeXMPScript == undefined) {    ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');}//----- DO THE THING -----////processFinishing('[[{"path":"~/Desktop/testing%20files/163084-1_scale.pdf","name":"163084-1_scale.pdf","quantity":1,"nesting":false,"finishedHeight":53,"finishedWidth":552,"cutOffset":[0,0,0,0],"useDocumentArtboard":false,"grommetStatus":true,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":true,"pocketSize":[2,4,2,2],"rotation":true,"tab":false}],{"source":"","scale":10,"regMarkSpacing":"36","zundCut":true,"materialWidth":"126","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}] ');//processFinishing('[[{"path":"~/Desktop/testing%20files/152007-1.pdf","name":"152007-1.pdf","quantity":1,"nesting":false,"finishedHeight":234,"finishedWidth":64.5,"cutOffset":[0,0,0,0],"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":true,"pocketSize":[1.25,1.25,1.25,1.25],"rotation":false,"tab":false}],{"source":"","scale":10,"regMarkSpacing":"36","zundCut":true,"materialWidth":"98","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}] ');//processFinishing('[[{"path":"~/Desktop/testing%20files/opacity%20mask%20test/162297-1scale.pdf","name":"162297-1scale.pdf","quantity":1,"nesting":false,"finishedHeight":68,"finishedWidth":720,"cutOffset":[0,0,0,0],"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":true,"pocketSize":[2,2,2,2],"rotation":true,"tab":false}],{"source":"","scale":10,"regMarkSpacing":"36","zundCut":true,"materialWidth":"150","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":true,"closeSource":false,"perimStroke":false}]');//processFinishing('[[{"path":"~/Desktop/testing%20files/opacity%20mask%20test/161350-1.pdf","name":"161350-1.pdf","quantity":1,"nesting":false,"finishedHeight":7.5,"finishedWidth":7.5,"cutOffset":[0,0,0,0],"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false,"tab":false}],{"source":"","scale":1,"regMarkSpacing":"12","zundCut":true,"materialWidth":"76","materialHeight":"52","rigid":true,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}] ');//----- FUNCTIONS -----////Initialization function, used to load action set if not presentfunction init(){    try {        app.unloadAction("PressBot Actions","");    } catch (e) {}    app.loadAction(File("~/Desktop/testing files/PressBot Actions.aia"));}//Function called from PressBot Extension to populate import list from opened filesfunction getOpenFiles(){    var files = [];    for(var i=0;i<app.documents.length;i++){        files.push(app.documents[i].fullName);    }    return files.toString(); //Data for extension must be returned as string}//Function called from PressBot Extension to import filesfunction addFiles(){    var files = [];    //Only allow user to select certain files    function filter(files){        if(files.constructor.name=="Folder"){return true};        if(files.name.match(/\.pdf$/)){return true};        if(files.name.match(/\.tif$/)){return true};        if(files.name.match(/\.tiff$/)){return true};        if(files.name.match(/\.eps$/)){return true};        if(files.name.match(/\.jpg$/)){return true};        if(files.name.match(/\.psd$/)){return true};        return false;    }    //Since user can select multiple files, create an array to hold them    files = File.openDialog("Select file(s) to import: ", filter, true);    //Add each item to the importFile array and the text box    if (files){        return files.toString(); //Data for extension must be returned as string    }}//PressBot Extension sends user input from extension to this function//This sends the same objects to PresssBot as the old createUI functionfunction processFinishing(string){    var userInput, lineItems = [], settings;    //Get user input from extension as array    userInput = eval('(' + string + ')');    //Apply user input to particular variables     lineItems = userInput.shift();    settings = userInput.shift();    //Convert array of anonymous objects into LineItem instances    for(var z=0;z<lineItems.length;z++){        lineItems[z] = new LineItem(            File(lineItems[z].path),            lineItems[z].name,            lineItems[z].quantity,            lineItems[z].nesting,            lineItems[z].finishedHeight,            lineItems[z].finishedWidth,            lineItems[z].cutOffset,            lineItems[z].useDocumentArtboard,            lineItems[z].grommetStatus,            lineItems[z].grommetSpacing,            lineItems[z].grommetByNumber,            lineItems[z].pocketStatus,            lineItems[z].pocketSize,            lineItems[z].rotation,            lineItems[z].tab,            undefined        );    }    //Make settings into PrintSettings instance too    settings = new PrintSettings(        settings.source,        settings.scale,        settings.regMarkSpacing,        settings.zundCut,        settings.materialWidth,        settings.materialHeight,        settings.rigid,        settings.perimPadding,        settings.save,        settings.closeSource,        settings.perimStroke    );    //Send finishing into to pressBot    try{        pressBot(lineItems, settings);    } catch(e){        if(debug){            alert(e + "\n At line " + e.line);        } else if(!debug) {            if(e.search("MRAP") != -1){                alert("Illustrator is out of memory. Restart Illustrator to continue using PressBot.");            } else {                alert(e);            }        }    }}//pressBot function takes an array of LineItem objects, collected from user input, uses them to call setup functionsfunction pressBot( lineItems, settings ){    //Array to contain objects which point to actual artwork for each line item    var allArtwork = [];    if(lineItems != null && settings != null){        //Run prepFiles function on each line item selected        for(var x=0; x<lineItems.length; x++){            allArtwork[x] = prepFiles( lineItems[x], settings );            lineItems[x].artworkObject = allArtwork[x];        }        //Run cutline, duplication, regmark and jobnumber functions if job is being zund-cut        //Check to make sure there are no null values in the allArtwork array, which are returned in case of an error        if (allArtwork.every(function(e){return e != null})){            printFiles( lineItems, settings );        }    }    //scriptPath = scriptDir = CMYKBlack = CMYKYellow = CMYKThruCut = CMYKKissCut = CMYKRegmarks = docPresets = allArtwork = null;    $.gc();    $.gc();}function prepFiles( fileObject, printSettings ){    //----- LOCAL FUNCTIONS -----//    //Cut line creation function    function createCutLayer ( targetDocument, tab, scale ){        //----- VARIABLE DECLARATION -----//        //Variables to hold cut layer and paths        var cutLayer, cutPathGroup;        //Assign cut layer to variable if it exists        for(var c=0;c<targetDocument.layers.length;c++){            if(targetDocument.layers[c].name == "Thru-cut") cutLayer = targetDocument.layers[c];        }        var targetArtboard = targetDocument.artboards[0];        //----- DO STUFF -----//        //If there is no pre-existing cut layer, create one        if(!cutLayer){            //Add cut layer            cutLayer = targetDocument.layers.add();            cutLayer.name = "Thru-cut";            cutLayer.visible = true;            //Create cut line around perimeter of artboard            var cutRect = cutLayer.pathItems.rectangle(                targetArtboard.artboardRect[1],                targetArtboard.artboardRect[0],                targetDocument.width, targetDocument.height )        } else {            cutLayer.visible = true;        }        //Group everything on cut layer together        cutPathGroup = groupArtworkOnLayer( cutLayer, "Thru-cut Path", targetDocument );        //If cut path is to have a tab, create one        if(tab){            var tabRect = cutPathGroup.pathItems.rectangle(                targetArtboard.artboardRect[3],                targetArtboard.artboardRect[2]-(scale*4),                scale*2, scale*1 );            cutPathGroup.selected = true;            app.executeMenuCommand("Live Pathfinder Add");            app.executeMenuCommand("expandStyle");            //Variable doesn't register expandStyle, so must reassign it to expanded art            cutPathGroup = cutLayer.pageItems[0];            cutPathGroup.selected = false;        }        //Make all shapes in cutGroup consistent        /*for (var i = 0; i < cutPathGroup.pathItems.length; i++){            cutPathGroup.pathItems[i].filled = false;            cutPathGroup.pathItems[i].stroked = true;            cutPathGroup.pathItems[i].strokeColor = CMYKThruCut;            cutPathGroup.pathItems[i].strokeWidth = (inchScalePixels*5) / 72;        }*/        setLayerPathColor( cutLayer, CMYKThruCut, scale);        targetArtboard = cutLayer = cutRect = tabRect = null;                return cutPathGroup;    }    //----- ERROR HANDLING -----//    try {        //Not sure if printSettings.source is needed any longer        //if (printSettings.source == "active" && app.documents.length == 0) throw "No file selected.";        //if (printSettings.source != "active" && !fileObject.path.exists) throw "File path is not valid.";        if (printSettings.scale < 0 || isNaN(printSettings.scale)) throw "Given scale is not a valid number.";        for(var i=0;i<4;i++){            if (isNaN(fileObject.grommetSpacing[i]) || isNaN(fileObject.pocketSize[i])) throw "Non-number values entered in grommet or pocket fields.";        }    }    catch(err) {        alert(err, "Error", true);        return null;    }    //----- VARIABLE DECLARATION -----//    //Active document and artboard    var importDocument, importArtboard;    //The actual artwork groups    var artworkGroup, cutGroup, kissCutGroup, pathForArtboard;    //Placement variable    var cutPathOffset = [], kissCutPathOffset = [], artboardOffset = [];    //Array with contains bleed size to add to artboard when expanding for Regmarks    var zundBleed = [0,0,0,0];    //Layers containing said groups    var layerOne, layerThruCut, layerKissCut;    //Scale    var inchScalePixels = 72 * (1/Number(printSettings.scale));    //----- FILE ORGANIZATION -----//    fileObject.path = new File(fileObject.path);    //Open file, assign document and artboard variables    if(!fileObject.path.exists){ importDocument = app.documents.getByName(stripExtension(fileObject.path)); }    else { importDocument = app.open(new File(fileObject.path)); }    importArtboard = importDocument.artboards[0];    //Set origin to top left corner    importDocument.rulerOrigin = [ 0, 0 ];    //Remove extension from the file name for use on labels    fileObject.name = stripExtension( importDocument.name );    //Deselect all art on all layers, delete empty and hidden layers, unlock locked layers    for (var i = importDocument.layers.length-1; i >= 0; i--){        importDocument.layers[i].hasSelectedArtwork = false;        if (importDocument.layers[i].locked == true) { importDocument.layers[i].locked = false; }        if (importDocument.layers[i].visible == false || importDocument.layers[i].pageItems.length == 0) {             importDocument.layers[i].visible = true;            importDocument.layers[i].remove();         }    }    //Set bottom layer name to "Layer 1" and assign to variable    importDocument.layers[importDocument.layers.length-1].name = "Layer 1";    layerOne = importDocument.layers.getByName("Layer 1");    //Crop artboard    if(fileObject.useDocumentArtboard == false) fileObject.cropArtboard( importDocument, printSettings );    //----- DO STUFF -----//    //Place grommets if needed    if (fileObject.grommetStatus == true){        fileObject.placeGrommets( importDocument, printSettings );    }    //Create pockets if needed    if (fileObject.pocketStatus == true){        fileObject.createPockets( importDocument, printSettings );    }    //Group all artwork onto bottom layer    artworkGroup = groupArtworkOnLayer( layerOne, "Artwork", importDocument );        //Populate zundBleed variable if needed    for(var x=0; x<fileObject.cutOffset.length; x++){        if(fileObject.cutOffset[x] < -.125 && (fileObject.pocketStatus == false || Math.abs(fileObject.cutOffset[x]) > fileObject.pocketSize[x])){            zundBleed[x] = Math.abs(fileObject.cutOffset[x]) * inchScalePixels;        }    }    //Create path for artboard for rotation and copying positions    pathForArtboard = layerOne.pathItems.rectangle(        importArtboard.artboardRect[1] + zundBleed[0],        importArtboard.artboardRect[0] - zundBleed[2],        importDocument.width + zundBleed[2] + zundBleed[3], importDocument.height + zundBleed[0] + zundBleed[1] );    pathForArtboard.stroked = false;    pathForArtboard.filled = false;    //Difference between visibleBounds and geometricBounds accounts for strokes    artboardOffset.push(artworkGroup.top - pathForArtboard.top + (artworkGroup.visibleBounds[0] - artworkGroup.geometricBounds[0]));    artboardOffset.push(artworkGroup.left - pathForArtboard.left - (artworkGroup.geometricBounds[2] - artworkGroup.visibleBounds[2]));    //Create a cut layer and cut file if needed (or standardize if existing)    if(printSettings.zundCut == true){        //Assign kiss and thru cut to variables if they are found, standardize paths, otherwise create cut layer        for (var i = importDocument.layers.length-1; i >= 0; i--){            if (importDocument.layers[i].name == "Thru-cut"){                cutGroup = createCutLayer( importDocument, fileObject.tab, inchScalePixels );                layerThruCut = importDocument.layers[i];            }            if (importDocument.layers[i].name == "Kiss-cut"){                layerKissCut = importDocument.layers.getByName("Kiss-cut");                kissCutGroup = groupArtworkOnLayer( layerKissCut, "Kiss-cut Path", importDocument);                setLayerPathColor( layerKissCut, CMYKKissCut);            }            if (!layerThruCut && i == 0) {                cutGroup = createCutLayer( importDocument, fileObject.tab, inchScalePixels );                layerThruCut = importDocument.layers.getByName("Thru-cut");            }        }        //Was having trouble with files that had a stroke but also had art behind a clipping mask        //If there is no clipping mask hiding artwork, these variables record the difference between visible bounds and geometric bounds        var artStrokeBleedNothingHiddenTop, artStrokeBleedNothingHiddenLeft;        if(artworkGroup.top == artworkGroup.geometricBounds[1]) {            artStrokeBleedNothingHiddenTop = 0;        } else {            artStrokeBleedNothingHiddenTop = artworkGroup.visibleBounds[1] - artworkGroup.geometricBounds[1];        }        if(artworkGroup.left == artworkGroup.geometricBounds[0]) {            artStrokeBleedNothingHiddenLeft = 0;        } else {            artStrokeBleedNothingHiddenLeft = artworkGroup.geometricBounds[0] - artworkGroup.visibleBounds[0];        }                //Get cut line position for rotation and duplication purposes        //This is the same as artboardOffset with adjustments for cut path stroke        if(layerThruCut){            cutPathOffset.push(                artworkGroup.top - (cutGroup.top + (cutGroup.visibleBounds[0] - cutGroup.geometricBounds[0])) - artStrokeBleedNothingHiddenTop            );            cutPathOffset.push(                artworkGroup.left - (cutGroup.left - (cutGroup.geometricBounds[2] - cutGroup.visibleBounds[2])) + artStrokeBleedNothingHiddenLeft            );        }        if(layerKissCut){            kissCutPathOffset.push(                artworkGroup.top - (kissCutGroup.top + (kissCutGroup.visibleBounds[0] - kissCutGroup.geometricBounds[0])) - artStrokeBleedNothingHiddenTop            );            kissCutPathOffset.push(                artworkGroup.left - (kissCutGroup.left - (kissCutGroup.geometricBounds[2] - kissCutGroup.visibleBounds[2])) + artStrokeBleedNothingHiddenLeft            );        }    }   //Artwork constructor (name, artGroup, artLayer, cutPath, cutPathOffset, cutLayer, kissCutPath, kissCutPathOffset, kissCutLayer, artboardPath, artboardOffset, opacityMasksPresent)    var artworkObject = new Artwork(        fileObject.name,        artworkGroup,        layerOne,        cutGroup,        cutPathOffset,        layerThruCut,        kissCutGroup,        kissCutPathOffset,        layerKissCut,        pathForArtboard,        artboardOffset,        false    )    //Check for any opacity masks    //var opacityMasksPrep = [];    //releaseOpacityMasks( artworkObject.artGroup, opacityMasksPrep );    //Rotate artwork object if needed    if (fileObject.rotation == true){        artworkObject.rotateArt( importDocument );    }    /*if(opacityMasksPrep.length > 0) {        createOpacityMasks( opacityMasksPrep);        artworkObject.opacityMasksPresent = true;    }*/    //importDocument = importArtboard = artworkGroup = cutGroup = kissCutGroup = pathForArtboard = layerOne = layerThruCut = layerKissCut = opacityMasksPrep = null;    $.gc();    $.gc();    /*if (printSettings.save == true && printSettings.zundCut == false){        fileObject.saveOut( importDocument, printSettings );    }*/    return artworkObject;}function printFiles( fileObjects, printSettings ){    //----- LOCAL FUNCTIONS -----//    //Regmarks creation function    function placeRegMarks ( targetDocument, printSettings ){        var targetArtboard = targetDocument.artboards[0];        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        //RegMark size of 1/4"        var regMarkRadius = inchScalePixels / 4;        //Make RegMarks 36" apart        var regMarkSpacing = Number(printSettings.regMarkSpacing) * inchScalePixels;        //Padding distance is 1"... User will be able to set this later        var paddingTopBottom, paddingLeftRight;        printSettings.perimPadding[0] == true ? paddingTopBottom = .5 : paddingTopBottom = 1;        printSettings.perimPadding[1] == true ? paddingLeftRight = .5 : paddingLeftRight = 1;        //Make artboard 1" or .5" bigger for RegMarks        targetArtboard.artboardRect = [            targetArtboard.artboardRect[0] - (inchScalePixels * paddingLeftRight),            targetArtboard.artboardRect[1] + (inchScalePixels * paddingTopBottom),            targetArtboard.artboardRect[2] + (inchScalePixels * paddingLeftRight),            targetArtboard.artboardRect[3] - (inchScalePixels * paddingTopBottom)        ];        //Create Regmarks layer        var regLayer = targetDocument.layers.add();        regLayer.name = "Regmarks";        //Determine number of RegMarks for all sides        var regMarkWidthNum = Math.round((targetDocument.width - (inchScalePixels * paddingLeftRight)) / regMarkSpacing) || 1;        var regMarkHeightNum = Math.round((targetDocument.height - (inchScalePixels * paddingTopBottom)) / regMarkSpacing) || 1;        var regMarkWidthDistance = (targetDocument.width - (inchScalePixels * paddingLeftRight)) / regMarkWidthNum;        var regMarkHeightDistance = (targetDocument.height - (inchScalePixels * paddingTopBottom)) / regMarkHeightNum;        //Loop to set Regmarks evenly spaced along the top        for (var i = 0; i <= regMarkWidthNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[1] - ((inchScalePixels * (paddingTopBottom/2)) - (inchScalePixels / 8)),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)) + (regMarkWidthDistance*i),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the bottom        for (var i = 0; i <= regMarkWidthNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)) + (regMarkWidthDistance*i),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the left side        for (var i = 1; i < regMarkHeightNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)) + (regMarkHeightDistance*i),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the right side        for (var i = 1; i < regMarkHeightNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)) + (regMarkHeightDistance*i),                targetArtboard.artboardRect[2] - ((inchScalePixels * (paddingLeftRight/2)) + (inchScalePixels / 8)),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        targetArtboard = regMark = regLayer = null;    }    //Job# layer creation function    function createJobLayer ( jobName, targetDocument, printSettings ){        var targetArtboard = targetDocument.artboards[0];        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        var labelEdgeOffset = []; //bottom, right        printSettings.perimPadding[0] == true ? labelEdgeOffset[0] = .0625 : labelEdgeOffset[0] = .25;        printSettings.perimPadding[1] == true ? labelEdgeOffset[1] = .5 : labelEdgeOffset[1] = 1;        labelEdgeOffset[1] += 2.125 //Additional tab offset        //Create Job# layer        var jobLayer = targetDocument.layers.add();        jobLayer.name = "Job#";        //Create Job# in bottom right corner        var printLabel = targetDocument.textFrames.add();        printLabel.contents = jobName;        printLabel.textRange.characterAttributes.size = inchScalePixels / 3;        printLabel.textRange.characterAttributes.fillColor = CMYKBlack;        printLabel.textRange.characterAttributes.textFont = textFonts["MyriadPro-Bold"];        printLabel.textRange.paragraphAttributes.justification = Justification.RIGHT;        printLabel.position = [            (targetArtboard.artboardRect[2] - (printLabel.anchor[0] - printLabel.position[0])) - (inchScalePixels*labelEdgeOffset[1]),            (targetArtboard.artboardRect[3] + (printLabel.position[1] - printLabel.anchor[1])) + (inchScalePixels*labelEdgeOffset[0])        ];        //Copy it to top right corner        var printLabelTop = printLabel.duplicate();        printLabelTop.textRange.paragraphAttributes.justification = Justification.LEFT;        printLabelTop.rotate(180);        printLabelTop.position = [            (targetArtboard.artboardRect[2] - printLabelTop.width) - (inchScalePixels*labelEdgeOffset[1]),            (targetArtboard.artboardRect[1] - (printLabelTop.anchor[1] - printLabelTop.position[1]) - (inchScalePixels*labelEdgeOffset[0]))        ];        targetArtboard = jobLayer = printLabel = printLabelTop = null;    }        //Black stroke around art (mostly for double-sides)    function createPerimeterStroke ( targetDocument, printSettings){        var targetArtboard = targetDocument.artboards[0];        var targetLayer = targetDocument.layers.getByName("Layer 1");        var cutLayer = targetDocument.layers.getByName("Thru-cut");        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));                var pocketRect = targetLayer.pathItems.rectangle(            targetArtboard.artboardRect[1],            targetArtboard.artboardRect[0],            targetDocument.width, targetDocument.height )        pocketRect.filled = false;        pocketRect.strokeColor = CMYKBlack;        pocketRect.strokeWidth = inchScalePixels / 72;        targetArtboard = targetLayer = cutLayer = pocketRect = null;    }    //Nesting function    function nestArtwork( targetDocument, nestingObjects, printSettings ){        //----- VARIABLE DECLARATION -----//        var targetArtboard = targetDocument.artboards[0];        var targetLayerOne = targetDocument.layers.getByName("Layer 1");        var targetThruCut, targetKissCut;        for (var t = 0; t < targetDocument.layers.length; t++){            if (targetDocument.layers[t].name == "Thru-cut"){                targetThruCut = targetDocument.layers.getByName("Thru-cut");            }            if (targetDocument.layers[t].name == "Kiss-cut"){                targetKissCut = targetDocument.layers.getByName("Kiss-cut");            }        }        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        //Empty metaData array        metaData = [];        //Object to store in global metadata as job is being created        var lineItem = {};        var nestedOpacityMasks = [];        //Variable to return files that don't fit, to be re-nested in new file        var returnFiles = [], nestingOrder = [];        //Keep note of how many files were nested        var numberNested = [];        //Keep note of files that are too large for material altogether        var failed = "";        //Rows array holds the position on each row to place the artwork        var rows = [];        rows.push([0, 0]); //[left, top]        //Cols array holds column of rows for stacking vertically        var cols = [];        cols.push([0,0]);        //Group to collect individual artboards from nested files, then resize actual artboard to it        artboardGroup = targetLayerOne.groupItems.add();        //Space between nested files        var padding;        //Set padding dependent on if it's being cut on the Zund or not        printSettings.zundCut == true ? padding = 0.5 * inchScalePixels : padding = 0;        //Set perimter padding according to user selection        var perimPaddingTopBottom, perimPaddingLeftRight;        printSettings.perimPadding[0] == true ? perimPaddingTopBottom = .5 : perimPaddingTopBottom = 1;        printSettings.perimPadding[1] == true ? perimPaddingLeftRight = .5 : perimPaddingLeftRight = 1;        //Variables to be set in the loop for each file being nested        var artHeight, artWidth, artwork, nestedArtwork, nestedCutPath, nestedKissCutPath, nestedArtboard, artboardGroup, jobLabel;        //This variable offsets the insertion point according to the size of the file        //Using the actual 0,0 point of the document often ends up nesting files off the canvas altogether        var overallOffset;        //Functional size is the maximum size that the art will be nested in        //To start, set at 1" less than material size on all sides to allow for regmarks, etc        var functionalWidth = (printSettings.materialWidth * inchScalePixels) - (inchScalePixels * perimPaddingLeftRight * 2);        var functionalHeight = (printSettings.materialHeight * inchScalePixels) - (inchScalePixels * perimPaddingTopBottom * 2);        //----- FILE ORGANIZATION -----//        //Organize files by size to pass them through the nesting loop by size        if(nestingObjects.length>1){            //Map index, area and height to temporary array            var nestingMap = nestingObjects.map( function(obj, i) {                return { index: i, name: obj.name, area: obj.artworkObject.artboardPath.area, height: obj.artworkObject.artboardPath.height };            });            //First sort temp array in ascending order numerically            /*nestingMap.sort(function(a, b) {                return Number(a.name.split("-")[1].match(/\d+/)) - Number(b.name.split("-")[1].match(/\d+/));            });*/            //This will sort objects by size in decending order, and in numerically ascending order if the size is equal            nestingMap.sort( function(a,b) {                if(a.area === b.area){                    return Number(a.name.split("-")[1].match(/\d+/)) - Number(b.name.split("-")[1].match(/\d+/));                } else {                    return b.area - a.area;                }            });            //Create new variable to hold full objects, reordered by area            nestingOrder = nestingMap.map( function(e){                return nestingObjects[e.index];            });            //Determine maximum height, either 124" or the tallest file other than that            var nestingLongest = nestingMap.reduce( function(a,b) {                return (a.height > b.height ? a : b);            }, printSettings);            //If longest file is larger than functionalHeight but will still fit on PDF and is on a roll, set it to longest file            if(printSettings.rigid == false && functionalHeight < nestingLongest.height && nestingLongest.height < (198 * 72)){ functionalHeight = nestingLongest.height; }        //If there is only one file in array, skip reordering        } else if (nestingObjects.length == 1){            nestingOrder.push(nestingObjects[0]);            //If longest file is larger than functionalHeight but will still fit on PDF and is on a roll, set it to longest file            if (printSettings.rigid == false && functionalHeight < nestingObjects[0].artworkObject.artboardPath.height && nestingObjects[0].artworkObject.artboardPath.height < (198 * 72)){                functionalHeight = nestingObjects[0].artworkObject.artboardPath.height;            }        }        //----- ART PLACEMENT LOOP -----//        //Cycle through array which contains each line item in order of size        for(var i=0; i<nestingOrder.length; i++){                        //----- SET VARIABLES FOR EACH FILE -----//                        numberNested[i] = 0;            artHeight = nestingOrder[i].artworkObject.artboardPath.height;            artWidth = nestingOrder[i].artworkObject.artboardPath.width;            artwork = nestingOrder[i].artworkObject;            lineItem = {name:"",quantity:0};            //On first iteration, set offset variables            if(i==0) {                //overallOffset centers art on canvas (more or less)                overallOffset = [artWidth, artHeight/2];                //placementOffset places nested artwork relative to first line item nested                //This is needed for files with elemets within and beyond the clipping mask bounds                placementOffset = [artwork.artboardOffset[0], artwork.artboardOffset[1]];            }            //If file is too large for the material, note it and skip to next iteration            if (artHeight > functionalHeight || artWidth > functionalWidth) {                failed += nestingOrder[i].name + "\n";                numberNested.splice(i, 1);                continue;            }            lineItem.name = nestingOrder[i].name;            //----- PLACE THE FILE FOR REALS -----//            //For total quantity of each line item...            for(var x=1; x<=nestingOrder[i].quantity; x++){                //On roll, test if artwork can be placed on any existing rows, starting from bottom                if(printSettings.rigid == false){                    for(var z=0; z<rows.length; z++){                        //Cycle through each row until there is one with enough space within the maximum material size                        if (artWidth + Math.abs(rows[z][0]) <= functionalWidth && artHeight + Math.abs(rows[z][1]) <= functionalHeight){                                                        //Copy artwork, cutpath (if needed) and artboard reference into new document                            nestedArtwork = artwork.artGroup.duplicate( targetLayerOne );                            if(printSettings.zundCut == true && targetThruCut) nestedCutPath = artwork.cutPath.duplicate( targetThruCut );                            if(printSettings.zundCut == true && targetKissCut) nestedKissCutPath = artwork.kissCutPath.duplicate( targetKissCut );                            nestedArtboard = artwork.artboardPath.duplicate( targetLayerOne );                                                        //if(artwork.opacityMasksPresent) releaseOpacityMasks( nestedArtwork, nestedOpacityMasks );                              //$.writeln("mask length: " + nestedOpacityMasks.length + " nest cycle: " + x);                                                        //Move artwork, cutpath (if needed) and artboard reference into position as determined by the insertion point of the current row                            //.position array is [left, top], *offset arrays are [top, left] - I know, I know, and I'm sorry                            if(rows[z] == [0, 0]) { nestedArtwork.position = [                                (rows[z][0] - artWidth) + overallOffset[0],                                (rows[z][1] + artHeight) - overallOffset[1]                            ];                            //After artwork for first item is placed, offset all other items relative to the first item                            } else { nestedArtwork.position = [                                (rows[z][0] - artWidth - placementOffset[1] + artwork.artboardOffset[1]) + overallOffset[0],                                (rows[z][1] + artHeight + artwork.artboardOffset[0] - placementOffset[0]) - overallOffset[1]                            ];}                                                    if(printSettings.zundCut == true && targetThruCut) nestedCutPath.position = [nestedArtwork.position[0] - artwork.cutPathOffset[1], nestedArtwork.position[1] - artwork.cutPathOffset[0]];                            if(printSettings.zundCut == true && targetKissCut) nestedKissCutPath.position = [nestedArtwork.position[0] - artwork.kissCutPathOffset[1], nestedArtwork.position[1] - artwork.kissCutPathOffset[0]];                            nestedArtboard.position = [nestedArtwork.position[0] - artwork.artboardOffset[1], nestedArtwork.position[1] - artwork.artboardOffset[0]];                                                        //Add artboard reference into the artboard group                            nestedArtboard.move(artboardGroup, ElementPlacement.PLACEATEND);                            //Move the insertion point for the current row to the left of the placed file                            rows[z] = [rows[z][0] - artWidth - padding, rows[z][1]];                            //If loop is on the top row, add another row for potential files                            if (z+1==rows.length){ rows[z+1] = [0, rows[z][1] + artHeight + padding]; }                            numberNested[i] += 1;                            lineItem.quantity += 1;                            //With art placed, break out of loop so it doesn't keep adding rows forever                            break;                        //If artwork has cycled through all rows and won't fit, adjust quantity and add it to files being returned                        } else if (z+1==rows.length){                            nestingOrder[i].quantity = nestingOrder[i].quantity - numberNested[i];                            returnFiles.push(nestingOrder[i]);                            x = nestingOrder[i].quantity;                            break;                        }                    }                //On rigid material, arrange in columns, so it populates vertically                } else {                    for(var z=0; z<cols.length; z++){                        //Cycle through each row until there is one with enough space within the maximum material size                        if (artWidth + Math.abs(cols[z][0]) <= functionalWidth && artHeight + Math.abs(cols[z][1]) <= functionalHeight){                                                        //Copy artwork, cutpath (if needed) and artboard reference into new document                            nestedArtwork = artwork.artGroup.duplicate( targetLayerOne );                            if(printSettings.zundCut == true && targetThruCut) nestedCutPath = artwork.cutPath.duplicate( targetThruCut );                            if(printSettings.zundCut == true && targetKissCut) nestedKissCutPath = artwork.kissCutPath.duplicate( targetKissCut );                            nestedArtboard = artwork.artboardPath.duplicate( targetLayerOne );                                                        //if(artwork.opacityMasksPresent) releaseOpacityMasks( nestedArtwork, nestedOpacityMasks );                               //$.writeln("mask length: " + nestedOpacityMasks.length + " nest cycle: " + x);                                                        //Move artwork, cutpath (if needed) and artboard reference into position as determined by the insertion point of the current row                            //.position array is [left, top], *offset arrays are [top, left] - I know, I know, and I'm sorry                            if(cols[z] == [0, 0]) { nestedArtwork.position = [                                (cols[z][0] - artWidth) + overallOffset[0],                                (cols[z][1] + artHeight) - overallOffset[1]                            ];                            //After artwork for first item is placed, offset all other items relative to the first item                            } else { nestedArtwork.position = [                                (cols[z][0] - artWidth - placementOffset[1] + artwork.artboardOffset[1]) + overallOffset[0],                                (cols[z][1] + artHeight + artwork.artboardOffset[0] - placementOffset[0]) - overallOffset[1]                            ];}                                                    if(printSettings.zundCut == true && targetThruCut) nestedCutPath.position = [nestedArtwork.position[0] - artwork.cutPathOffset[1], nestedArtwork.position[1] - artwork.cutPathOffset[0]];                            if(printSettings.zundCut == true && targetKissCut) nestedKissCutPath.position = [nestedArtwork.position[0] - artwork.KissCutPathOffset[1], nestedArtwork.position[1] - artwork.kissCutPathOffset[0]];                                nestedArtboard.position = [nestedArtwork.position[0] - artwork.artboardOffset[1], nestedArtwork.position[1] - artwork.artboardOffset[0]];                                                        //Add artboard reference into the artboard group                            nestedArtboard.move(artboardGroup, ElementPlacement.PLACEATEND);                            //If loop is on the last column, add another column to the left for potential files                            if (z+1==cols.length){ cols[z+1] = [cols[z][0] - artWidth - padding, cols[z][1]]; }                            //Move the insertion point for the current column to the top of the placed file                            cols[z] = [cols[z][0], cols[z][1] + artHeight + padding];                            numberNested[i] += 1;                            lineItem.quantity += 1;                            //With art placed, break out of loop so it doesn't keep adding rows forever                            break;                        //If artwork has cycled through all rows and won't fit, adjust quantity and add it to files being returned                        } else if (z+1==cols.length){                            nestingOrder[i].quantity = nestingOrder[i].quantity - numberNested[i];                            returnFiles.push(nestingOrder[i]);                            x = nestingOrder[i].quantity;                            break;                        }                    }                }            }            //Add lineItem info object to metadata if it was nested            if(lineItem.quantity>0) metaData.push(lineItem);        }        //Alert user of any files that were too large        if(failed != ""){            alert("The following file(s) were too large to be nested: \n" + failed);        }        //If at least 1 file was sucessfully nested, prep file for finishing functions        if(numberNested.length > 0){            //Center artboard and all artwork within the drawing area            //First group everything on art layer and cut layer (except the artboardGroup)            var printGroup = groupArtworkOnLayer( targetLayerOne, "Print Group", targetDocument );            if(targetThruCut){                var cutGroup = groupArtworkOnLayer( targetThruCut, "Thru-cut Group", targetDocument );            }            if(targetKissCut){                var kissCutGroup = groupArtworkOnLayer( targetKissCut, "Kiss-cut Group", targetDocument );            }            artboardGroup.move(targetLayerOne, ElementPlacement.PLACEATEND);            //Determine offsets            var printGroupOffsetLeft = printGroup.left - artboardGroup.left;            var printGroupOffsetTop = printGroup.top - artboardGroup.top;            if(cutGroup){                var cutGroupOffsetLeft = cutGroup.left - artboardGroup.left;                var cutGroupOffsetTop = cutGroup.top - artboardGroup.top;            }            if(kissCutGroup){                var kissCutGroupOffsetLeft = kissCutGroup.left - artboardGroup.left;                var kissCutGroupOffsetTop = kissCutGroup.top - artboardGroup.top;            }            //Center artboard            artboardGroup.left = artboardGroup.width/-2;            artboardGroup.top = artboardGroup.height/2;            //Set artboard to size of artwork            artboardGroup.selected = true;            targetDocument.fitArtboardToSelectedArt(0);            artboardGroup.remove();            //Move artwork and cut groups to new artboard location, relative to their offsets            printGroup.left = targetDocument.artboards[0].artboardRect[0] + printGroupOffsetLeft;            printGroup.top = targetDocument.artboards[0].artboardRect[1] + printGroupOffsetTop;            if(cutGroup){                cutGroup.left = targetDocument.artboards[0].artboardRect[0] + cutGroupOffsetLeft;                cutGroup.top = targetDocument.artboards[0].artboardRect[1] + cutGroupOffsetTop;            }            if(kissCutGroup){                kissCutGroup.left = targetDocument.artboards[0].artboardRect[0] + kissCutGroupOffsetLeft;                kissCutGroup.top = targetDocument.artboards[0].artboardRect[1] + kissCutGroupOffsetTop;            }            //if(nestedOpacityMasks.length > 0) createOpacityMasks(nestedOpacityMasks);                    //Determine regmark spacing based on number of rows or columns            //Currently having user do this            /*var reg;            if(rows.length > 1) {                reg = Math.round((targetDocument.height / (rows.length - 1)) / inchScalePixels);                if (reg < 36) printSettings.regMarkSpacing = reg;            }            if(cols.length > 1) {                reg = Math.round((targetDocument.width / (cols.length - 1)) / inchScalePixels);                if (reg < 36) printSettings.regMarkSpacing = reg;            }*/            nestedOpacityMasks = undefined;            numberNested = [];            return returnFiles;        } else { return null; }    }    //----- ERROR HANDLING -----//    //Make sure Print.ai preset is present    try {        if (!app.startupPresetsList.some(function(e){return e == "Print"})) throw "\'Print.ai\' preset not found.";    }    catch(err) {        alert(err, "Error", true);        return;    }    //----- VARIABLE DECLARATION -----//    var printDocument, printArtboard, printLayerOne, printThruCut, printKissCut;    var nestingFiles = [], printFile = [];    var nestingDocument, nestingArtboard, nestingLayerOne, nestingThruCut, nestingKissCut;    //Scale    var inchScalePixels = printSettings.scale;    //Info to send to XMPMeta object    var metaData = [], jobLabel;    //Create XMPMeta object to add metadata to file    var xmpTarget;    //----- DO STUFF -----//    //Cycle through all files, separating nested from non-nesting files    for(var x=0; x<fileObjects.length; x++){                //----- NOT NESTING -----//                //If the current file is not being nested, send through nesting function all by its lonesome        if(fileObjects[x].nesting == false){            //If file object is 1up and not on the Zund, skip all printFiles processes            if(printSettings.zundCut == false && fileObjects[x].quantity == 1) continue;            //nestArtwork function requires an array, place art info into one            printFile.push(fileObjects[x]);            //Create a new document for each un-nested file, if it is being cut on Zund            //while(printFile != null && printFile.length > 0){                try{                    printDocument = app.documents.addDocument("Basic CMYK");                }catch(e){                    printDocument = app.documents.addDocument("Print");                }                //Assign XMPMeta object to add metadata to file                xmpTarget = new XMPMeta(printDocument.XMPString);                //Add cut layers                if(printFile[0].artworkObject.cutPath){                    printThruCut = printDocument.layers.add();                    printThruCut.name = "Thru-cut";                    printThruCut.visible = true;                }                if(printFile[0].artworkObject.kissCutPath){                    printKissCut = printDocument.layers.add();                    printKissCut.name = "Kiss-cut";                    printKissCut.visible = true;                }                //Place artwork into new document using nestArtwork function                printFile = nestArtwork( printDocument, printFile, printSettings );                if(printFile != null){                                        //Create regmarks and job layer                    if(printSettings.zundCut == true){                        placeRegMarks( printDocument, printSettings );                        if(metaData[0].quantity > 1){                            qtyUpLabel = "_" + metaData[0].quantity + "up";                        } else {                            qtyUpLabel = "";                        }                        createJobLayer( fileObjects[x].name + qtyUpLabel, printDocument, printSettings );                    }                                    //Add perimeter stroke                    if(printSettings.perimStroke) createPerimeterStroke( printDocument, printSettings );                                        //Add metatags                    xmpTarget.setProperty(XMPConst.NS_XMP, "PrintType", "Print");                    xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentHeight", Math.round((printDocument.height/72) * 100) / 100);                    xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentWidth", Math.round((printDocument.width/72) * 100) / 100);                    xmpTarget.setProperty(XMPConst.NS_XMP, "LineItem", metaData[0].name);                    xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", metaData[0].quantity);                    xmpTarget.setProperty(XMPConst.NS_XMP, "OtherLineItems", " ");                    if(printKissCut){                        xmpTarget.setProperty(XMPConst.NS_XMP, "CutType", "Kiss Cut / Thru Cut");                    }else{                        xmpTarget.setProperty(XMPConst.NS_XMP, "CutType", "Thru Cut");                    }                    xmpTarget.setProperty(XMPConst.NS_XMP, "Scale", inchScalePixels);                    printDocument.XMPString = xmpTarget.serialize(XMPConst.SERIALIZE_USE_COMPACT_FORMAT);                                        //Save file                    if(printSettings.save) fileObjects[x].saveOut( printDocument, printSettings );                } else if(printFile == null && printSettings.closeSource) {                    printDocument.close(SaveOptions.DONOTSAVECHANGES);                }                    //Empty printFile array            printFile = [];        } else if(fileObjects[x].nesting == true){            //Extract files to be nested            nestingFiles.push(fileObjects[x]);        }    }    //----- NESTING -----//    //Nest files together    while (nestingFiles != null && nestingFiles.length > 0){        //Set file name and save location to first element in nestingFiles (organize this later)        var nestingJobName = nestingFiles[0].name;        var nestingJobPath = nestingFiles[0].path;        //Bind LineItem's saveOut function to name and path determined above        var nestSave = nestingFiles[0].saveOut.bind( nestingFiles[0] );        var qtyUpLabel = "", otherLines = "";        //Create new document for nesting        try{            nestingDocument = app.documents.addDocument("Basic CMYK");        }catch(e){            nestingDocument = app.documents.addDocument("Print");        }        //Assign XMPMeta object to add metadata to file        xmpTarget = new XMPMeta(nestingDocument.XMPString);        for(var n=0; n<nestingFiles.length; n++){            if(nestingFiles[n].artworkObject.cutPath){                nestingThruCut = nestingDocument.layers.add();                nestingThruCut.name = "Thru-cut";                nestingThruCut.visible = true;                break            }            if(nestingFiles[n].artworkObject.kissCutPath){                nestingKissCut = nestingDocument.layers.add();                nestingKissCut.name = "Kiss-cut";                nestingKissCut.visible = true;                break;            }        }        //Nest!        nestingFiles = nestArtwork( nestingDocument, nestingFiles, printSettings );        //Once all files have been nested, add regmarks and job layer, save out        if(nestingFiles != null){            //Determine lowest line item number for job label            jobLabel = metaData.reduce( function(a,b) {                return (Number(a.name.split("-")[1].match(/\d+/)) < Number(b.name.split("-")[1].match(/\d+/)) ? a : b);            }).name;            //List other line items in file            for(var m=0;m<metaData.length;m++){                if (metaData[m].name != jobLabel) otherLines += "-" + metaData[m].name.split("-")[1] + " ";            }            if(printSettings.zundCut == true){                //Place RegMarks and Job# layers                placeRegMarks( nestingDocument, printSettings );                if(metaData.length == 1 && metaData[0].quantity > 1) qtyUpLabel = "_" + metaData[0].quantity + "up";                createJobLayer( jobLabel + qtyUpLabel, nestingDocument, printSettings );            }            if(printSettings.perimStroke) createPerimeterStroke( nestingDocument, printSettings );            //Add metatags            xmpTarget.setProperty(XMPConst.NS_XMP, "PrintType", "Print");            xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentHeight", Math.round((nestingDocument.height/72) * 100) / 100);            xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentWidth", Math.round((nestingDocument.width/72) * 100) / 100);            xmpTarget.setProperty(XMPConst.NS_XMP, "LineItem", jobLabel);            xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", metaData[0].quantity);            xmpTarget.setProperty(XMPConst.NS_XMP, "OtherLineItems", otherLines);            if(nestingKissCut){                xmpTarget.setProperty(XMPConst.NS_XMP, "CutType", "Kiss Cut / Thru Cut");            }else{                xmpTarget.setProperty(XMPConst.NS_XMP, "CutType", "Thru Cut");            }            xmpTarget.setProperty(XMPConst.NS_XMP, "Scale", inchScalePixels);            nestingDocument.XMPString = xmpTarget.serialize(XMPConst.SERIALIZE_USE_COMPACT_FORMAT);            if(printSettings.save) nestSave( nestingDocument, printSettings );        }    }    //If nestArtwork returned null because nothing was nested, close    if(nestingFiles == null) nestingDocument.close(SaveOptions.DONOTSAVECHANGES);    //Close all source files    if(printSettings.closeSource){        for(var z=fileObjects.length-1; z>=0; z--){            for(var n = app.documents.length-1; n>=0; n--) {                if(app.documents[n].name == fileObjects[z].path.name) app.documents[n].close(SaveOptions.DONOTSAVECHANGES);            }        }    }    //printDocument = printArtboard = printLayerOne = printThruCut = printKissCut = printSettings = fileObjects = nestingFiles = printFile = xmpTarget = null;    //nestingDocument = nestingArtboard = nestingLayerOne = nestingThruCut = nestingKissCut = null;    $.gc();    $.gc();}//Release and save opacity masksfunction releaseOpacityMasks ( artGroup, opacityMasks ){    var currentItem, originalSelection, expandedSelection;        //Release single opacity masks within a group - action will not reach them otherwise    for(var i=artGroup.pageItems.length-1;i>0;i--){        currentItem = artGroup.pageItems[i];        if(currentItem.typename == "GroupItem" && currentItem.pageItems.length == 1 && currentItem.pageItems[0].typename == "GroupItem"){            if(currentItem.pageItems[0].pageItems.length == 1){                currentItem.selected = true;                executeMenuCommand("ungroup");                executeMenuCommand("deselectall");            }        }    }    currentItem = undefined;    executeMenuCommand("deselectall");    for(var n=artGroup.pageItems.length-1;n>=0;n--){        currentItem = artGroup.pageItems[n];        //$.writeln(currentItem.typename);        if(currentItem.typename == "GroupItem" || currentItem.typename == "RasterItem"){                        currentItem.selected = true;            originalSelectionLength = app.activeDocument.selection.length;            app.doScript("release opacity mask", "PressBot Actions", false);            expandedSelectionLength = app.activeDocument.selection.length;            if(expandedSelectionLength > originalSelectionLength) {                opacityMasks.push(app.activeDocument.selection);                $.writeln("expanded: true");            }            //app.activeDocument.selection.selected = false;            executeMenuCommand("deselectall");         }        if(currentItem.typename == "GroupItem"){            releaseOpacityMasks( currentItem, opacityMasks );        }    }    currentItem = originalSelection = expandedSelection = null;    return;}//Create opacity masksfunction createOpacityMasks ( opacityMasks ){    for(var x=opacityMasks.length-1;x>=0;x--){        $.writeln("opacityMasks " + x + " length: " + opacityMasks[x].length);        for(var z=opacityMasks[x].length-1;z>=0;z--){            opacityMasks[x][z].selected = true;        }        app.doScript("create opacity mask", "PressBot Actions", false);        executeMenuCommand("deselectall");    }    opacityMasks = [];}//Place all artwork on a specified layer into a groupfunction groupArtworkOnLayer( layer, groupName, targetDocument ){    //Remove hidden items, unlock locked items    for (var i=layer.pageItems.length-1; i>=0; i--){        layer.pageItems[i].locked = false;        if (layer.pageItems[i].hidden == true){            layer.pageItems[i].remove();        }    }    //Remove guides    for (var x=layer.pathItems.length-1; x>=0; x--){        if (layer.pathItems[x].guides == true){            layer.pathItems[x].hidden = false;            layer.pathItems[x].locked = false;            layer.pathItems[x].remove();        }    }    //Select all artwork on selected layer    layer.hasSelectedArtwork = true;    var activeSelection = targetDocument.selection;    //Create a group for the selected artwork to go into    var artwork = layer.groupItems.add();    artwork.name = groupName;    //Move selected art into group on layer and then deselect it    for (var z=0; z < activeSelection.length; z++){        activeSelection[z].move(artwork, ElementPlacement.PLACEATEND);        activeSelection[z].selected = false;    }    layer.hasSelectedArtwork = false;    activeSelection = null        return artwork;}function setLayerPathColor( layer, color, scale){            var strokeThickness, currentItem;    //Calling function should have already set inchScalePixels    scale == 72 ? strokeThickness = 5 : strokeThickness = 1;        for(var p=0; p < layer.pageItems.length; p++){        currentItem = layer.pageItems[p];        changeColors (currentItem);    }    function changeColors ( currentItem ){        if(currentItem.typename == "PathItem"){            currentItem.filled = false;            currentItem.stroked = true;            currentItem.strokeColor = color;            currentItem.strokeWidth = strokeThickness;        } else if(currentItem.typename == "CompoundPathItem"){            for(var cp = 0; cp < currentItem.pathItems.length; cp++){                currentItem.pathItems[cp].filled = false;                currentItem.pathItems[cp].stroked = true;                currentItem.pathItems[cp].strokeColor = color;                currentItem.pathItems[cp].strokeWidth = strokeThickness;            }        } else if(currentItem.typename == "GroupItem"){            for(var gi = 0; gi < currentItem.pageItems.length; gi++){                changeColors( currentItem.pageItems[gi] );            }        }        }    currentItem = null;}//Function strips extension, path directory & _* from the document name//This is like the most useful function I've made so farfunction stripExtension( docName ){    var fileName = docName.toString();    var pos = fileName.lastIndexOf(".");    var slashpos = fileName.lastIndexOf("/");    var scorepos = fileName.lastIndexOf("_");    if(pos != -1){ fileName = fileName.substring(pos, -1); }    if(slashpos != -1){ fileName = fileName.substring(slashpos+1); }    if(scorepos != -1){ fileName = fileName.substring(scorepos, -1); }    return fileName;}