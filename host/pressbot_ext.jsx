/*Version index:v1012: Nesting horizontally mostly works, all non-batching bugs fixedv1013: Material width is back, minor batching bugs fixed, minor tweaks (automatically closing source files, adding "scale" to file name, import multiple files)       To do - material width and auto-closing do not work with nesting. Also, figure out how to duplicate and/or nest vertically if material width is exceeded.v1014: RELEASE V3       Same as v1013 except nesting has been disabled.v1015: Encapsulate code where possible so it's easier to upgrade, make object constructors to store data and artwork       This will also pare down global variables       Other minor fixes: opening unsaved files, canceling out of UI, pocket label placement, handling of hidden and locked layers       Nesting still turned off in this versionv1015 nesting 1: Nesting testing ... figuring out this branch thing      nesting 2: Got some very basic nesting to work, using rows onlyv1016: Rolling out new UI to accomodate nesting easierv2000: New release version with mostly functional nesting*///----- POLYFILLS -----////Array polyfills, pulled from developer.mozilla.orgif (!Array.prototype.indexOf) {  Array.prototype.indexOf = function(searchElement, fromIndex) {    var k;    // 1. Let O be the result of calling ToObject passing    //    the this value as the argument.    if (this == null) {      throw new TypeError('"this" is null or not defined');    }    var O = Object(this);    // 2. Let lenValue be the result of calling the Get    //    internal method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If len is 0, return -1.    if (len === 0) {      return -1;    }    // 5. If argument fromIndex was passed let n be    //    ToInteger(fromIndex); else let n be 0.    var n = +fromIndex || 0;    if (Math.abs(n) === Infinity) {      n = 0;    }    // 6. If n >= len, return -1.    if (n >= len) {      return -1;    }    // 7. If n >= 0, then Let k be n.    // 8. Else, n<0, Let k be len - abs(n).    //    If k is less than 0, then let k be 0.    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);    // 9. Repeat, while k < len    while (k < len) {      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the      //    HasProperty internal method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      //    i.  Let elementK be the result of calling the Get      //        internal method of O with the argument ToString(k).      //   ii.  Let same be the result of applying the      //        Strict Equality Comparison Algorithm to      //        searchElement and elementK.      //  iii.  If same is true, return k.      if (k in O && O[k] === searchElement) {        return k;      }      k++;    }    return -1;  };}if (!Array.prototype.every) {  Array.prototype.every = function(callbackfn, thisArg) {    'use strict';    var T, k;    if (this == null) {      throw new TypeError('this is null or not defined');    }    // 1. Let O be the result of calling ToObject passing the this    //    value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get internal method    //    of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.    if (typeof callbackfn !== 'function') {      throw new TypeError();    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length > 1) {      T = thisArg;    }    // 6. Let k be 0.    k = 0;    // 7. Repeat, while k < len    while (k < len) {      var kValue;      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty internal      //    method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal method        //    of O with argument Pk.        kValue = O[k];        // ii. Let testResult be the result of calling the Call internal method        //     of callbackfn with T as the this value and argument list        //     containing kValue, k, and O.        var testResult = callbackfn.call(T, kValue, k, O);        // iii. If ToBoolean(testResult) is false, return false.        if (!testResult) {          return false;        }      }      k++;    }    return true;  };}if (!Array.prototype.some) {  Array.prototype.some = function(fun /*, thisArg*/) {    'use strict';    if (this == null) {      throw new TypeError('Array.prototype.some called on null or undefined');    }    if (typeof fun !== 'function') {      throw new TypeError();    }    var t = Object(this);    var len = t.length >>> 0;    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;    for (var i = 0; i < len; i++) {      if (i in t && fun.call(thisArg, t[i], i, t)) {        return true;      }    }    return false;  };}if (!Array.prototype.map) {  Array.prototype.map = function(callback, thisArg) {    var T, A, k;    if (this == null) {      throw new TypeError(' this is null or not defined');    }    // 1. Let O be the result of calling ToObject passing the |this|    //    value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get internal    //    method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If IsCallable(callback) is false, throw a TypeError exception.    // See: http://es5.github.com/#x9.11    if (typeof callback !== 'function') {      throw new TypeError(callback + ' is not a function');    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length > 1) {      T = thisArg;    }    // 6. Let A be a new array created as if by the expression new Array(len)    //    where Array is the standard built-in constructor with that name and    //    len is the value of len.    A = new Array(len);    // 7. Let k be 0    k = 0;    // 8. Repeat, while k < len    while (k < len) {      var kValue, mappedValue;      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty internal      //    method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal        //    method of O with argument Pk.        kValue = O[k];        // ii. Let mappedValue be the result of calling the Call internal        //     method of callback with T as the this value and argument        //     list containing kValue, k, and O.        mappedValue = callback.call(T, kValue, k, O);        // iii. Call the DefineOwnProperty internal method of A with arguments        // Pk, Property Descriptor        // { Value: mappedValue,        //   Writable: true,        //   Enumerable: true,        //   Configurable: true },        // and false.        // In browsers that support Object.defineProperty, use the following:        // Object.defineProperty(A, k, {        //   value: mappedValue,        //   writable: true,        //   enumerable: true,        //   configurable: true        // });        // For best browser support, use the following:        A[k] = mappedValue;      }      // d. Increase k by 1.      k++;    }    // 9. return A    return A;  };}if (!Array.prototype.reduce) {  Array.prototype.reduce = function(callback /*, initialValue*/) {    'use strict';    if (this == null) {      throw new TypeError('Array.prototype.reduce called on null or undefined');    }    if (typeof callback !== 'function') {      throw new TypeError(callback + ' is not a function');    }    var t = Object(this), len = t.length >>> 0, k = 0, value;    if (arguments.length == 2) {      value = arguments[1];    } else {      while (k < len && ! k in t) {        k++;      }      if (k >= len) {        throw new TypeError('Reduce of empty array with no initial value');      }      value = t[k++];    }    for (; k < len; k++) {      if (k in t) {        value = callback(value, t[k], k, t);      }    }    return value;  };}if (!Function.prototype.bind) {  Function.prototype.bind = function(oThis) {    if (typeof this !== 'function') {      // closest thing possible to the ECMAScript 5      // internal IsCallable function      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');    }    var aArgs   = Array.prototype.slice.call(arguments, 1),        fToBind = this,        fNOP    = function() {},        fBound  = function() {          return fToBind.apply(this instanceof fNOP && oThis                 ? this                 : oThis,                 aArgs.concat(Array.prototype.slice.call(arguments)));        };    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;  };}//----- OBJECT CONSTRUCTORS W/PROPERTIES -----////LineItem object constructor - this object holds all finishing information for each line item. Instances of these objects are created in createUI()function LineItem(path, name, quantity, nesting, finishedHeight, finishedWidth, cutOffset, useDocumentArtboard, grommetStatus, grommetSpacing, grommetByNumber, pocketStatus, pocketSize, rotation, artworkObject) {    this.path = path;    this.name = name;    this.quantity = quantity;    this.nesting = nesting; //"Yes" or "No"    this.finishedHeight = finishedHeight;    this.finishedWidth = finishedWidth;    this.cutOffset = cutOffset; //array [top, bottom, left, right]    this.useDocumentArtboard = useDocumentArtboard;    this.grommetStatus = grommetStatus; //boolean    this.grommetSpacing = grommetSpacing; //array [top, bottom, left, right]    this.grommetByNumber = grommetByNumber; //array to determine if grommets are placed by number(=1) or distance(=0), array in order of [horizontal, vertical]    this.pocketStatus = pocketStatus; //boolean    this.pocketSize = pocketSize; //array [top, bottom, left, right]    this.rotation = rotation;    this.artworkObject = artworkObject; //Artwork object for this line item}//Artwork object constructor - this object references the actual artwork for the line item. Instances of these objects are created in prepFiles()function Artwork(name, artGroup, artLayer, cutPath, cutPathOffset, cutLayer, artboardPath, artboardOffset) {    this.name = name;    this.artGroup = artGroup;    this.artLayer = artLayer;    this.cutPath = cutPath;    this.cutPathOffset = cutPathOffset; //array for cut path offset [top, left]    this.cutLayer = cutLayer;    this.artboardPath = artboardPath;    this.artboardOffset = artboardOffset;}//PrintSettings object constructor - this object holds information which applies to all line itemsfunction PrintSettings(source, scale, regMarkSpacing, zundCut, materialWidth, materialHeight, rigid, perimPadding, save, closeSource, perimStroke){    this.source = source; //info from source panel, one of "active", "all", or "external"    this.scale = scale;    this.regMarkSpacing = regMarkSpacing;    this.zundCut = zundCut; //boolean    this.materialWidth = materialWidth;    this.materialHeight = materialHeight;    this.rigid = rigid; //Print material is rigid    this.perimPadding = perimPadding;    this.save = save; //boolean    this.closeSource = closeSource;    this.perimStroke = perimStroke;}//----- OBJECT METHODS -----//LineItem.prototype.cropArtboard = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    //Set scale    var inchScalePixels = 72 * (1/Number(settings.scale));    var heightDiff = 0, widthDiff = 0;    //----- MATHS -----//        //If finishedHeight & finishedWidth is > 0, determine difference between targetDocument height & width and lineItem height & width    /*if(this.finishedHeight > 0 && this.finishedWidth > 0){        //Determine difference between finished size and artboard size        if(targetDocument.height != this.finishedHeight){            var heightDiff = (targetDocument.height - (this.finishedHeight * inchScalePixels))/2;        }        if(targetDocument.width != this.finishedWidth){            var widthDiff = (targetDocument.width - (this.finishedWidth * inchScalePixels))/2;        }    }    //If finishedHeight & finishedWidth is <= 0, reduce artboard size by that amount    if(this.finishedHeight <= 0 && this.finishedWidth <= 0){        var heightDiff = Math.abs(this.finishedHeight * inchScalePixels);        var widthDiff = Math.abs(this.finishedWidth * inchScalePixels);    }    //If cutOffset is <= 0, reduce artboard size by that amount    if(this.cutOffset <= 0){        heightDiff = Math.abs(this.cutOffset * inchScalePixels);        widthDiff = heightDiff;    }*/    //----- DO STUFF -----//    //Shrink artboard to finished size    targetArtboard.artboardRect = [        targetArtboard.artboardRect[0] - this.cutOffset[2] * inchScalePixels, //widthDiff,        targetArtboard.artboardRect[1] + this.cutOffset[0] * inchScalePixels, //heightDiff,        targetArtboard.artboardRect[2] + this.cutOffset[3] * inchScalePixels, //widthDiff,        targetArtboard.artboardRect[3] - this.cutOffset[1] * inchScalePixels //heightDiff    ];}//Place grommets into target documentLineItem.prototype.placeGrommets = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    var targetLayer = targetDocument.layers.getByName("Layer 1");    //Set scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //Create group for grommets    var grommetGroup = targetLayer.groupItems.add();    grommetGroup.name = "Grommets";    //Array to calculate grommet this.grommetSpacing according to scale, same indexes as this.grommetSpacing    var spacingPixels = [];    spacingPixels.length = 4;    //Array to calculate grommet distances, follows same indexes as fileObject.grommetSpacing    var grommetDistanceFromEdge = [];    grommetDistanceFromEdge.length = 4;    //Array to calculate grommet distance according to scale, same indexes as distanceFromEdge    var distanceFromEdgePixels = [];    distanceFromEdgePixels.length = 4;    //Grommet size of 1/8"    var grommetRadius  = inchScalePixels / 8;    //Grommet quantity array index: 0 = top, 1 = bottom, 2 = left, 3 = right;    var grommetNum = [];    grommetNum.length = 4;    //Grommet actual this.grommetSpacing, same index - this variable stores pixels needed to actually place the grommets evenly    var actualSpacing = []    actualSpacing.length = 4;    //----- MATHS -----//    for(var i=0;i<4;i++){        //Determine distance from the edge for the grommets        if (this.pocketSize[i] > 0 && this.pocketSize[i] < 1) {            grommetDistanceFromEdge[i] = this.pocketSize[i];        } else if (this.pocketSize[i] >= 1 && this.pocketSize[i] <= 2 || this.pocketSize[i] == 0) {            grommetDistanceFromEdge[i] = 1;        } else if (this.pocketSize[i] > 2) {            grommetDistanceFromEdge[i] = this.pocketSize[i] - .5;        }        //Set grommet spacing and distance according to scale        spacingPixels[i] = this.grommetSpacing[i] * inchScalePixels;        distanceFromEdgePixels[i] = grommetDistanceFromEdge[i] * inchScalePixels;    }    //----- DO STUFF -----//    //Determine actual grommet placement & place them onto file    for(var i = 0; i < grommetNum.length; i ++){        //----- MORE MATHS -----//        //Calculate actual grommet this.grommetSpacing in pixels        switch (i) {        //Top & bottom        case 0:        case 1:            //If user entered invalid numbers (too small or too large), avoid running math that would divide by 0            if (spacingPixels[i] <= 0 || (spacingPixels[i] > targetDocument.width && this.grommetByNumber[0] == 0)){                grommetNum[i] = 0;                actualSpacing[i] = 0;            } else {                //If user selected grommets by distance, determine number of grommets                if (this.grommetByNumber[0] == 0){                    grommetNum[i] = Math.round((targetDocument.width - (distanceFromEdgePixels[2] + distanceFromEdgePixels[3]))/(spacingPixels[i])) + 1;                //If user specified number of grommets, directly plug that number into the grommetNum variable                } else if (this.grommetByNumber[0] == 1){                    grommetNum[i] = this.grommetSpacing[i];                }                //Avoid dividing by invalid numbers                if (grommetNum[i] <= 1){                    actualSpacing[i] = 0;                } else {                    //Get the actual this.grommetSpacing needed between top & bottom grommets for this particular banner                    actualSpacing[i] = (targetDocument.width - (distanceFromEdgePixels[2] + distanceFromEdgePixels[3])) / (grommetNum[i] - 1);                }            }            break;        //Left & right        case 2:        case 3:            //If user entered invalid numbers (too small or too large), avoid running math that would divide by 0            if (spacingPixels[i] <= 0 || (spacingPixels[i] > targetDocument.height && this.grommetByNumber[1] == 0)){                grommetNum[i] = 0;                actualSpacing[i] = 0;            } else {                //If user selected grommets by distance, determine number of grommets                if (this.grommetByNumber[1] == 0){                    grommetNum[i] = Math.round((targetDocument.height - (distanceFromEdgePixels[0] + distanceFromEdgePixels[1]))/(spacingPixels[i])) + 1;                //If user specified number of grommets, directly plug that number into the grommetNum variable                } else if (this.grommetByNumber[1] == 1){                    grommetNum[i] = this.grommetSpacing[i];                }                //Avoid dividing by invalid numbers                if (grommetNum[i] <= 1){                    actualSpacing[i] = 0;                } else {                    //Get the actual this.grommetSpacing needed between left & right grommets for this particular banner                    actualSpacing[i] = (targetDocument.height - (distanceFromEdgePixels[0] + distanceFromEdgePixels[1])) / (grommetNum[i] - 1);                }            }            break;        }        //----- DO STUFF WITH MATHS -----//        //For each side, loop according to number of grommets on the side        for (var x = 0; x < grommetNum[i]; x++){            switch (i) {                //Place grommets along the top (x pos, y pos, height, width)                case 0:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[1] - (distanceFromEdgePixels[0] - (inchScalePixels/16)),                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[2] - (inchScalePixels/16)) + (actualSpacing[0]*x),                    grommetRadius, grommetRadius);                break;                //Place grommets along the bottom                case 1:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[1] + (inchScalePixels/16)),                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[2] - (inchScalePixels/16)) + (actualSpacing[1]*x),                    grommetRadius, grommetRadius);                break;                //Place grommets along the left                case 2:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[1] + (inchScalePixels/16)) + (actualSpacing[2]*x),                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[2] - (inchScalePixels/16)),                    grommetRadius, grommetRadius);                break;                //Place grommets along the right                case 3:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[1] + (inchScalePixels/16)) + (actualSpacing[3]*x),                    targetArtboard.artboardRect[2] - (distanceFromEdgePixels[3] + (inchScalePixels/16)),                    grommetRadius, grommetRadius);                break;            }            //Set appearance of each grommet            grommet.filled = true;            grommet.stroked = false;            grommet.fillColor = CMYKYellow;            grommet.fillColor.yellow = 50;            //Add each grommet to the group            grommet.move(grommetGroup, ElementPlacement.PLACEATEND);        }    }}//Add pockets to target documentLineItem.prototype.createPockets = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    var targetLayer = targetDocument.layers.getByName("Layer 1");    //Don't make pockets if all pocket sizes are < 0    var pocketsTrue = false;    //Array to store pocket size according to scale, follows same indexes as fileObject.pocketSize    var pocketSizePixels = [];    pocketSizePixels.length = 4;    //Scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //----- MATHS -----//    //Set pocket size according to scale    for(var i=0;i<4;i++){        pocketSizePixels[i] = this.pocketSize[i] * inchScalePixels;        if(pocketSizePixels[i] > 0) pocketsTrue = true;    }    //----- DO STUFF -----//    if(pocketsTrue){        //Make artboard bigger in all directions, according to pocket size given        targetArtboard.artboardRect = [            targetArtboard.artboardRect[0] - pocketSizePixels[2],            targetArtboard.artboardRect[1] + pocketSizePixels[0],            targetArtboard.artboardRect[2] + pocketSizePixels[3],            targetArtboard.artboardRect[3] - pocketSizePixels[1]        ];        //Create black rectangle stroke around perimeter of document size (x pos, y pos, width, height)        var pocketRect = targetLayer.pathItems.rectangle(            targetArtboard.artboardRect[1],            targetArtboard.artboardRect[0],            targetDocument.width, targetDocument.height )        pocketRect.filled = false;        pocketRect.strokeColor = CMYKBlack;        pocketRect.strokeWidth = inchScalePixels / 72;        //Create Job number in top left and bottom right corners        if(pocketSizePixels[0] > 0){            var pocketLabel = targetLayer.textFrames.add();            pocketLabel.contents = this.name;            pocketLabel.textRange.characterAttributes.size = inchScalePixels / 2;            pocketLabel.textRange.characterAttributes.fillColor = CMYKYellow;            pocketLabel.textRange.characterAttributes.textFont = textFonts["MyriadPro-Bold"];            pocketLabel.textRange.paragraphAttributes.justification = Justification.LEFT;            pocketLabel.rotate(180);            if(pocketSizePixels[1] > 0) var pocketLabelBottom = pocketLabel.duplicate( targetDocument, ElementPlacement.PLACEATEND);            pocketLabel.textRange.paragraphAttributes.justification = Justification.RIGHT;            pocketLabel.position = [ pocketSizePixels[2] > 0 ? pocketSizePixels[2] : inchScalePixels*2, targetArtboard.artboardRect[1] - (inchScalePixels*.125) ];            if(pocketSizePixels[1] > 0){                pocketLabelBottom.rotate(180);                pocketLabelBottom.position = [targetDocument.width - pocketLabelBottom.width - (pocketSizePixels[3] > 0 ? pocketSizePixels[3]*2 : inchScalePixels*2), (targetArtboard.artboardRect[1] - targetDocument.height) + (inchScalePixels/1.5)];                pocketLabelBottom.textRange.paragraphAttributes.justification = Justification.RIGHT;            }        }    }}//Save target documentLineItem.prototype.saveOut = function( targetDocument, settings ){        //----- VARIABLE DECLARATIONS -----//        //Scale        var inchScalePixels = 72 * (1/Number(settings.scale));        //Set PDF settings        var saveOptions = new PDFSaveOptions();        saveOptions.pDFPreset = 'Indy Imaging PDF 01_13';        //Set layers        var targetLayerOne = targetDocument.layers.getByName("Layer 1");        var printLabel = "";        if(settings.zundCut == true){            var targetThruCut = targetDocument.layers.getByName("Thru-cut");            targetThruCut.visible = false;            printLabel = "print";        }        var scaleLabel = "";        if(inchScalePixels<72){            scaleLabel = "_scale_";        }        //Make destination path same as existing path        var destFolderPrint = new Folder(this.path + "/" + this.name + scaleLabel + printLabel + ".pdf");        var destFolderCut = new Folder(this.path + "/" + this.name + scaleLabel + "cut.pdf");        var saveFile = destFolderPrint.saveDlg("Save print file");        if (saveFile) {            //If Zund is active, save both print and cut files - if not, save print file only            if (settings.zundCut == true){                targetDocument.saveAs(saveFile, saveOptions);                //Make cut layer visible and delete bottom later                targetThruCut.visible = true;                targetLayerOne.remove();                //Outline all text in document                for (var i = targetDocument.textFrames.length - 1; i > -1; i--){                    targetDocument.textFrames[i].createOutline();                }                //Save cut file                saveFile = destFolderCut.saveDlg("Save cut file");                if (saveFile) targetDocument.saveAs(saveFile, saveOptions);            } else {                targetDocument.saveAs(saveFile, saveOptions);            }        }    }//Rotate all artwork in fileArtwork.prototype.rotateArt = function( targetDocument ){    //----- DECLARE VARIABLES WITH MATHS -----//    var targetArtboard = targetDocument.artboards[0];    //var artboardOffsetTop = this.artGroup.top - targetArtboard.artboardRect[1];    //var artboardOffsetLeft = this.artGroup.left - targetArtboard.artboardRect[0];    var strokeDifference = (this.artGroup.visibleBounds[1] - this.artGroup.geometricBounds[1]) * 2;    //----- DO STUFF -----//    //Rotate artwork group    this.artGroup.rotate(-90);    //Rotate artboard    this.artboardPath.rotate(-90);    this.artboardPath.top = this.artGroup.top + this.artboardOffset[1];    this.artboardPath.left = this.artGroup.left + (this.artGroup.width - this.artboardPath.width + strokeDifference) - this.artboardOffset[0];    targetArtboard.artboardRect = [        this.artboardPath.geometricBounds[0],        this.artboardPath.geometricBounds[1],        this.artboardPath.geometricBounds[2],        this.artboardPath.geometricBounds[3]    ];    this.artboardOffset = [this.artGroup.top - this.artboardPath.top, this.artGroup.left - this.artboardPath.left]    //Rotate cut path group if property is defined, adjust cut path offset for copying to print file    if(this.cutPath){        this.cutPath.rotate(-90);        this.cutPath.top = this.artGroup.top + this.cutPathOffset[1];        this.cutPath.left = this.artGroup.left + (this.artGroup.width - this.cutPath.width) - this.cutPathOffset[0];        this.cutPathOffset = [this.artGroup.top - this.cutPath.top, this.artGroup.left - this.cutPath.left];    }}//----- GLOBAL VARIABLES -----////Set script directoryvar scriptPath = $.fileName.split("/");var scriptDir = scriptPath.slice(0, -1).join("/");//Set Blackvar CMYKBlack = new CMYKColor();CMYKBlack.black = 100;CMYKBlack.cyan = 0;CMYKBlack.magenta = 0;CMYKBlack.yellow = 0;//Set Yellowvar CMYKYellow = new CMYKColor();CMYKYellow.black = 0;CMYKYellow.cyan = 0;CMYKYellow.magenta = 0;CMYKYellow.yellow = 100;//Set Thru-cut colorvar CMYKThruCut = new CMYKColor();CMYKThruCut.black = 1;CMYKThruCut.cyan = 100;CMYKThruCut.magenta = 1;CMYKThruCut.yellow = 1;//Set Regmarks colorvar CMYKRegmarks = new CMYKColor();CMYKRegmarks.black = 100;CMYKRegmarks.cyan = 31;CMYKRegmarks.magenta = 31;CMYKRegmarks.yellow = 31;//Document presets to be used if Basic CMYK is not availablevar docPresets = new DocumentPreset();docPresets.units = RulerUnits.Inches;//Set up XMP API for adding metadataif (ExternalObject.AdobeXMPScript == undefined) {    ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');}//----- DO THE THING -----////processFinishing('[[{"path":"~/Desktop/testing%20files/presspot%202000%20tutorial/146213-1.pdf","name":"146213-1.pdf","quantity":2,"nesting":false,"finishedHeight":30,"finishedWidth":15,"cutOffset":[1,1,1,1],"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":true}],{"source":"","scale":1,"regMarkSpacing":"36","zundCut":true,"materialWidth":"54","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}]')//processFinishing('[[{"path":"/jobs/156023%20Signarama/cf/tiles/156023-3c.tif","name":"156023-3c.tif","quantity":1,"nesting":true,"finishedHeight":52,"finishedWidth":106.75,"cutOffset":-0.125,"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false},{"path":"/jobs/156023%20Signarama/cf/tiles/156023-2c.tif","name":"156023-2c.tif","quantity":1,"nesting":true,"finishedHeight":52,"finishedWidth":106.5,"cutOffset":-0.125,"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false},{"path":"/jobs/156023%20Signarama/cf/tiles/156023-1c.tif","name":"156023-1c.tif","quantity":1,"nesting":true,"finishedHeight":52,"finishedWidth":123.75,"cutOffset":-0.125,"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false}],{"source":"","scale":1,"regMarkSpacing":"36","zundCut":true,"materialWidth":"54","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}]');//----- FUNCTIONS -----////Function called from PressBot Extension to populate import list from opened filesfunction getOpenFiles(){    var files = [];    for(var i=0;i<app.documents.length;i++){        files.push(app.documents[i].fullName);    }    return files.toString(); //Data for extension must be returned as string}//Function called from PressBot Extension to import filesfunction addFiles(){    var files = [];    //Only allow user to select certain files    function filter(files){        if(files.constructor.name=="Folder"){return true};        if(files.name.match(/\.pdf$/)){return true};        if(files.name.match(/\.tif$/)){return true};        if(files.name.match(/\.tiff$/)){return true};        if(files.name.match(/\.eps$/)){return true};        if(files.name.match(/\.jpg$/)){return true};        if(files.name.match(/\.psd$/)){return true};        return false;    }    //Since user can select multiple files, create an array to hold them    files = File.openDialog("Select file(s) to import: ", filter, true);    //Add each item to the importFile array and the text box    if (files){        return files.toString(); //Data for extension must be returned as string    }}//PressBot Extension sends user input from extension to this function//This sends the same objects to PresssBot as the old createUI functionfunction processFinishing(string){    var userInput, lineItems = [], settings;    //Get user input from extension    userInput = eval('(' + string + ')');    //Apply user input to particular variables     lineItems = userInput.shift();    settings = userInput.shift();    //Convert array of anonymous objects into LineItem instances    for(var z=0;z<lineItems.length;z++){        lineItems[z] = new LineItem(            File(lineItems[z].path),            lineItems[z].name,            lineItems[z].quantity,            lineItems[z].nesting,            lineItems[z].finishedHeight,            lineItems[z].finishedWidth,            lineItems[z].cutOffset,            lineItems[z].useDocumentArtboard,            lineItems[z].grommetStatus,            lineItems[z].grommetSpacing,            lineItems[z].grommetByNumber,            lineItems[z].pocketStatus,            lineItems[z].pocketSize,            lineItems[z].rotation,            undefined        );    }    //Make settings into PrintSettings instance too    settings = new PrintSettings(        settings.source,        settings.scale,        settings.regMarkSpacing,        settings.zundCut,        settings.materialWidth,        settings.materialHeight,        settings.rigid,        settings.perimPadding,        settings.save,        settings.closeSource,        settings.perimStroke    );    //Send finishing into to pressBot    pressBot(lineItems, settings);}//pressBot function takes an array of LineItem objects, collected from user input, uses them to call setup functionsfunction pressBot( lineItems, settings ){    //Array to contain objects which point to actual artwork for each line item    var allArtwork = [];        if(lineItems != null && settings != null){        //Run prepFiles function on each line item selected        for(var x=0; x<lineItems.length; x++){            allArtwork[x] = prepFiles( lineItems[x], settings );            lineItems[x].artworkObject = allArtwork[x];        }        //Run cutline, duplication, regmark and jobnumber functions if job is being zund-cut        //Check to make sure there are no null values in the allArtwork array, which are returned in case of an error        if (allArtwork.every(function(e){return e != null})){            printFiles( lineItems, settings );        }    }}function prepFiles( fileObject, printSettings ){    //----- LOCAL FUNCTIONS -----//    //Cut line creation function    function createCutLayer ( targetDocument ){        //----- VARIABLE DECLARATION -----//        //Variables to hold cut layer and paths        var cutLayer, cutPathGroup;        var targetArtboard = targetDocument.artboards[0];        //----- DO STUFF -----//        //Find out if there is a Thru-cut layer and assign to variable if there is        for (var i = 0; i < targetDocument.layers.length; i++){            if (targetDocument.layers[i].name == "Thru-cut"){                cutLayer = importDocument.layers.getByName("Thru-cut");            }        }        //If there is no pre-existing cut layer, create one        if(!cutLayer){            //Add cut layer            cutLayer = targetDocument.layers.add();            cutLayer.name = "Thru-cut";            cutLayer.visible = true;            //Create cut line around perimeter of artboard            var cutRect = cutLayer.pathItems.rectangle(                targetArtboard.artboardRect[1],                targetArtboard.artboardRect[0],                targetDocument.width, targetDocument.height )        } else {            cutLayer.visible = true;        }        //Group everything on cut layer together        cutPathGroup = groupArtworkOnLayer( cutLayer, "Cut Path", targetDocument );        //Make all shapes in cutGroup consistent        for (var i = 0; i < cutPathGroup.pathItems.length; i++){            cutPathGroup.pathItems[i].filled = false;            cutPathGroup.pathItems[i].stroked = true;            cutPathGroup.pathItems[i].strokeColor = CMYKThruCut;            cutPathGroup.pathItems[i].strokeWidth = (inchScalePixels*5) / 72;        }        return cutPathGroup;    }    //----- ERROR HANDLING -----//    try {        //Not sure if printSettings.source is needed any longer        //if (printSettings.source == "active" && app.documents.length == 0) throw "No file selected.";        //if (printSettings.source != "active" && !fileObject.path.exists) throw "File path is not valid.";        if (printSettings.scale < 0 || isNaN(printSettings.scale)) throw "Given scale is not a valid number.";        for(var i=0;i<4;i++){            if (isNaN(fileObject.grommetSpacing[i]) || isNaN(fileObject.pocketSize[i])) throw "Non-number values entered in grommet or pocket fields.";        }    }    catch(err) {        alert(err, "Error", true);        return null;    }    //----- VARIABLE DECLARATION -----//    //Active document and artboard    var importDocument, importArtboard;    //The actual artwork groups    var artworkGroup, cutGroup, pathForArtboard;    //Placement variable    var cutPathOffset = [], artboardOffset = [];    //Layers containing said groups    var layerOne, layerThruCut;    //Scale    var inchScalePixels = 72 * (1/Number(printSettings.scale));    //----- FILE ORGANIZATION -----//    fileObject.path = new File(fileObject.path);    //Open file, assign document and artboard variables    if(!fileObject.path.exists){ importDocument = app.documents.getByName(stripExtension(fileObject.path)); }    else { importDocument = app.open(new File(fileObject.path)); }    importArtboard = importDocument.artboards[0];    //Set origin to top left corner    importDocument.rulerOrigin = [ 0, 0 ];    //Remove extension from the file name for use on labels    fileObject.name = stripExtension( importDocument.name );    //Deselect all art on all layers, delete empty and hidden layers, unlock locked layers    for (var i = importDocument.layers.length-1; i >= 0; i--){        importDocument.layers[i].hasSelectedArtwork = false;        if (importDocument.layers[i].locked == true) { importDocument.layers[i].locked = false; }        if (importDocument.layers[i].visible == false || importDocument.layers[i].pageItems.length == 0) {             importDocument.layers[i].visible = true;            importDocument.layers[i].remove();         }    }    //Set bottom layer name to "Layer 1" and assign to variable    importDocument.layers[importDocument.layers.length-1].name = "Layer 1";    layerOne = importDocument.layers.getByName("Layer 1");    //Crop artboard to finished size, if selected in UI    if(fileObject.useDocumentArtboard == false) fileObject.cropArtboard( importDocument, printSettings );    //----- DO STUFF -----//    //Place grommets if needed    if (fileObject.grommetStatus == true){        fileObject.placeGrommets( importDocument, printSettings );    }    //Create pockets if needed    if (fileObject.pocketStatus == true){        fileObject.createPockets( importDocument, printSettings );    }    //Group all artwork onto bottom layer    artworkGroup = groupArtworkOnLayer( layerOne, "Artwork", importDocument );        var zundBleed = [0,0,0,0];    for(var x=0; x<fileObject.cutOffset.length; x++){        if(fileObject.cutOffset[x] < -.125) zundBleed[x] = Math.abs(fileObject.cutOffset[x]) * inchScalePixels;    }    //Create path for artboard for rotation and copying positions    pathForArtboard = layerOne.pathItems.rectangle(        importArtboard.artboardRect[1] + zundBleed[0],        importArtboard.artboardRect[0] - zundBleed[2],        importDocument.width + zundBleed[2] + zundBleed[3], importDocument.height + zundBleed[0] + zundBleed[1] );    pathForArtboard.stroked = false;    pathForArtboard.filled = false;    //Difference between visibleBounds and geometricBounds accounts for strokes    artboardOffset.push(artworkGroup.top - pathForArtboard.top + (artworkGroup.visibleBounds[0] - artworkGroup.geometricBounds[0]));    artboardOffset.push(artworkGroup.left - pathForArtboard.left - (artworkGroup.geometricBounds[2] - artworkGroup.visibleBounds[2]));    //Create a cut layer and cut file if needed (or standardize if existing)    if(printSettings.zundCut == true){        cutGroup = createCutLayer( importDocument );        //Assign cut layer to variable        layerThruCut = importDocument.layers.getByName("Thru-cut");        //Was having trouble with files that had a stroke but also had art behind a clipping mask        //Using these variables seems to resolve it usually        var artStrokeBleedNothingHiddenTop, artStrokeBleedNothingHiddenLeft;        if(artworkGroup.top == artworkGroup.geometricBounds[1]) {            artStrokeBleedNothingHiddenTop = 0;        } else {            artStrokeBleedNothingHiddenTop = artworkGroup.visibleBounds[1] - artworkGroup.geometricBounds[1];        }        if(artworkGroup.left == artworkGroup.geometricBounds[0]) {            artStrokeBleedNothingHiddenLeft = 0;        } else {            artStrokeBleedNothingHiddenLeft = artworkGroup.geometricBounds[0] - artworkGroup.visibleBounds[0];        }                //Get cut line position for rotation and duplication purposes        //This is the same as artboardOffset with adjustments for cut path stroke        cutPathOffset.push(          //artworkGroup.top - (cutGroup.top + (cutGroup.visibleBounds[0] - cutGroup.geometricBounds[0])) + (artworkGroup.visibleBounds[0] - artworkGroup.geometricBounds[0])            artworkGroup.top - (cutGroup.top + (cutGroup.visibleBounds[0] - cutGroup.geometricBounds[0])) - artStrokeBleedNothingHiddenTop        );        cutPathOffset.push(          //artworkGroup.left - (cutGroup.left - (cutGroup.geometricBounds[2] - cutGroup.visibleBounds[2])) - (artworkGroup.geometricBounds[2] - artworkGroup.visibleBounds[2])            artworkGroup.left - (cutGroup.left - (cutGroup.geometricBounds[2] - cutGroup.visibleBounds[2])) + artStrokeBleedNothingHiddenLeft        );    }   //Artwork constructor (name, artGroup, artLayer, cutPath, cutPathOffset, cutLayer, artboardPath, artboardOffset)    var artworkObject = new Artwork(        fileObject.name,        artworkGroup,        layerOne,        cutGroup,        cutPathOffset,        layerThruCut,        pathForArtboard,        artboardOffset    )    //Rotate artwork object if needed    if (fileObject.rotation == true){        artworkObject.rotateArt( importDocument );    }    if (printSettings.save == true && printSettings.zundCut == false){        fileObject.saveOut( importDocument, printSettings );    }    return artworkObject;}function printFiles( fileObjects, printSettings ){    //----- LOCAL FUNCTIONS -----//    //Regmarks creation function    function placeRegMarks ( targetDocument, printSettings ){        var targetArtboard = targetDocument.artboards[0];        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        //RegMark size of 1/4"        var regMarkRadius = inchScalePixels / 4;        //Make RegMarks 36" apart        var regMarkSpacing = Number(printSettings.regMarkSpacing) * inchScalePixels;        //Padding distance is 1"... User will be able to set this later        var paddingTopBottom, paddingLeftRight;        printSettings.perimPadding[0] == true ? paddingTopBottom = .5 : paddingTopBottom = 1;        printSettings.perimPadding[1] == true ? paddingLeftRight = .5 : paddingLeftRight = 1;        //Make artboard .5" bigger for RegMarks        targetArtboard.artboardRect = [            targetArtboard.artboardRect[0] - (inchScalePixels * paddingLeftRight),            targetArtboard.artboardRect[1] + (inchScalePixels * paddingTopBottom),            targetArtboard.artboardRect[2] + (inchScalePixels * paddingLeftRight),            targetArtboard.artboardRect[3] - (inchScalePixels * paddingTopBottom)        ];        //Create Regmarks layer        var regLayer = targetDocument.layers.add();        regLayer.name = "Regmarks";        //Determine number of RegMarks for all sides        var regMarkWidthNum = Math.round((targetDocument.width - (inchScalePixels * paddingLeftRight)) / regMarkSpacing);        var regMarkHeightNum = Math.round((targetDocument.height - (inchScalePixels * paddingTopBottom)) / regMarkSpacing);        var regMarkWidthDistance = (targetDocument.width - (inchScalePixels * paddingLeftRight)) / regMarkWidthNum;        var regMarkHeightDistance = (targetDocument.height - (inchScalePixels * paddingTopBottom))/regMarkHeightNum;        if (regMarkWidthNum == 0){            regMarkWidthNum = 1;        }        if (regMarkHeightNum == 0){            regMarkHeightNum = 1;        }        //Loop to set Regmarks evenly spaced along the top        for (var i = 0; i <= regMarkWidthNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[1] - ((inchScalePixels * (paddingTopBottom/2)) - (inchScalePixels / 8)),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)) + (regMarkWidthDistance*i),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the bottom        for (var i = 0; i <= regMarkWidthNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)) + (regMarkWidthDistance*i),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the left side        for (var i = 1; i < regMarkHeightNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)) + (regMarkHeightDistance*i),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the right side        for (var i = 1; i < regMarkHeightNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)) + (regMarkHeightDistance*i),                targetArtboard.artboardRect[2] - ((inchScalePixels * (paddingLeftRight/2)) + (inchScalePixels / 8)),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }    }    //Job# layer creation function    function createJobLayer ( jobName, targetDocument, printSettings ){        var targetArtboard = targetDocument.artboards[0];        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        var labelEdgeOffset = []; //bottom, right        printSettings.perimPadding[0] == true ? labelEdgeOffset[0] = .0625 : labelEdgeOffset[0] = .25;        printSettings.perimPadding[1] == true ? labelEdgeOffset[1] = .5 : labelEdgeOffset[1] = 1;        labelEdgeOffset[1] += 2.125 //Additional tab offset        //Create Job# layer        var jobLayer = targetDocument.layers.add();        jobLayer.name = "Job#";        //Create Job# in bottom right corner        var printLabel = targetDocument.textFrames.add();        printLabel.contents = jobName;        printLabel.textRange.characterAttributes.size = inchScalePixels / 3;        printLabel.textRange.characterAttributes.fillColor = CMYKBlack;        printLabel.textRange.characterAttributes.textFont = textFonts["MyriadPro-Bold"];        printLabel.textRange.paragraphAttributes.justification = Justification.RIGHT;        printLabel.position = [            (targetArtboard.artboardRect[2] - (printLabel.anchor[0] - printLabel.position[0])) - (inchScalePixels*labelEdgeOffset[1]),            (targetArtboard.artboardRect[3] + (printLabel.position[1] - printLabel.anchor[1])) + (inchScalePixels*labelEdgeOffset[0])        ];        //Copy it to top right corner        var printLabelTop = printLabel.duplicate();        printLabelTop.textRange.paragraphAttributes.justification = Justification.LEFT;        printLabelTop.rotate(180);        printLabelTop.position = [            (targetArtboard.artboardRect[2] - printLabelTop.width) - (inchScalePixels*labelEdgeOffset[1]),            (targetArtboard.artboardRect[1] - (printLabelTop.anchor[1] - printLabelTop.position[1]) - (inchScalePixels*labelEdgeOffset[0]))        ];    }        //Black stroke around art (mostly for double-sides)    function createPerimeterStroke ( targetDocument, printSettings){        var targetArtboard = targetDocument.artboards[0];        var targetLayer = targetDocument.layers.getByName("Layer 1");        var cutLayer = targetDocument.layers.getByName("Thru-cut");        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));                var pocketRect = targetLayer.pathItems.rectangle(            targetArtboard.artboardRect[1],            targetArtboard.artboardRect[0],            targetDocument.width, targetDocument.height )        pocketRect.filled = false;        pocketRect.strokeColor = CMYKBlack;        pocketRect.strokeWidth = inchScalePixels / 72;    }    //Nesting function    function nestArtwork( targetDocument, nestingObjects, printSettings ){        //----- VARIABLE DECLARATION -----//        var targetArtboard = targetDocument.artboards[0];        var targetLayerOne = targetDocument.layers.getByName("Layer 1");        var targetThruCut = targetDocument.layers.add();        targetThruCut.name = "Thru-cut";        targetThruCut.visible = true;        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        //Object to store in global metadata as job is being created        var lineItem = {};        //Variable to return files that don't fit, to be re-nested in new file        var returnFiles = [], nestingOrder = [];        //Keep note of how many files were nested        var numberNested = [];        //Keep note of files that are too large for material altogether        var failed = "";        //Rows array holds the position on each row to place the artwork        var rows = [];        rows.push([0, 0]); //[left, top]        //Cols array holds column of rows for stacking vertically        var cols = [];        cols.push([0,0]);        //Group to collect individual artboards from nested files, then resize actual artboard to it        artboardGroup = targetLayerOne.groupItems.add();        //Space between nested files        var padding;        //Set padding dependent on if it's being cut on the Zund or not        printSettings.zundCut == true ? padding = 0.5 * inchScalePixels : padding = 0;        //Variables to be set in the loop for each file being nested        var artHeight, artWidth, artwork, nestedArtwork, nestedCutPath, nestedArtboard, artboardGroup, jobLabel;        //This variable offsets the insertion point according to the size of the file        //Using the actual 0,0 point of the document often ends up nesting files off the canvas altogether        var overallOffset;        //Functional size is the maximum size that the art will be nested in        //To start, set at .5" less than material size on all sides to allow for regmarks, etc        var functionalWidth = (printSettings.materialWidth * inchScalePixels) - (inchScalePixels * 0.5);        var functionalHeight = (printSettings.materialHeight * inchScalePixels) - (inchScalePixels * 0.5);        //----- FILE ORGANIZATION -----//        //Organize files by size to pass them through the nesting loop by size        if(nestingObjects.length>1){            //Map index, area and height to temporary array            var nestingMap = nestingObjects.map( function(obj, i) {                return { index: i, name: obj.name, area: obj.artworkObject.artboardPath.area, height: obj.artworkObject.artboardPath.height };            });            //First sort temp array in ascending order numerically            /*nestingMap.sort(function(a, b) {                return Number(a.name.split("-")[1].match(/\d/)) - Number(b.name.split("-")[1].match(/\d/));            });*/            //This will sort objects by size in decending order, and in numerically ascending order if the size is equal            nestingMap.sort( function(a,b) {                if(a.area === b.area){                    return Number(a.name.split("-")[1].match(/\d/)) - Number(b.name.split("-")[1].match(/\d/));;                } else {                    return b.area - a.area;                }            });            //Create new variable to hold full objects, reordered by area            nestingOrder = nestingMap.map( function(e){                return nestingObjects[e.index];            });            //Determine maximum height, either 124" or the tallest file other than that            var nestingLongest = nestingMap.reduce( function(a,b) {                return (a.height > b.height ? a : b);            }, printSettings);            //If longest file is larger than functionalHeight but will still fit on PDF and is on a roll, set it to longest file            if(printSettings.rigid == false && functionalHeight < nestingLongest.height && nestingLongest.height < (198 * 72)){ functionalHeight = nestingLongest.height; }        //If there is only one file in array, skip reordering        } else if (nestingObjects.length == 1){            nestingOrder.push(nestingObjects[0]);            //If longest file is larger than functionalHeight but will still fit on PDF and is on a roll, set it to longest file            if (printSettings.rigid == false && functionalHeight < nestingObjects[0].artworkObject.artboardPath.height && nestingObjects[0].artworkObject.artboardPath.height < (198 * 72)){                functionalHeight = nestingObjects[0].artworkObject.artboardPath.height;            }        }        //----- ART PLACEMENT LOOP -----//        //Cycle through array which contains each line item in order of size        for(var i=0; i<nestingOrder.length; i++){            //----- SET VARIABLES FOR EACH FILE -----//            numberNested[i] = 0;            artHeight = nestingOrder[i].artworkObject.artboardPath.height;            artWidth = nestingOrder[i].artworkObject.artboardPath.width;            artwork = nestingOrder[i].artworkObject;            lineItem = {name:"",quantity:0};            //On first iteration, set offset variables            if(i==0) {                //overallOffset centers art on canvas (more or less)                overallOffset = [artWidth, artHeight/2];                //placementOffset places nested artwork relative to first line item nested                //This is needed for files with elemets within and beyond the clipping mask bounds                placementOffset = [artwork.artboardOffset[0], artwork.artboardOffset[1]];            }            //If file is too large for the material, note it and skip to next iteration            if (artHeight > functionalHeight || artWidth > functionalWidth) {                failed += nestingOrder[i].name + "\n";                numberNested.splice(i, 1);                continue;            }            lineItem.name = nestingOrder[i].name;            //----- PLACE THE FILE FOR REALS -----//            //For total quantity of each line item...            for(var x=1; x<=nestingOrder[i].quantity; x++){                //On roll, test if artwork can be placed on any existing rows, starting from bottom                if(printSettings.rigid == false){                    for(var z=0; z<rows.length; z++){                        //Cycle through each row until there is one with enough space within the maximum material size                        if (artWidth + Math.abs(rows[z][0]) <= functionalWidth && artHeight + Math.abs(rows[z][1]) <= functionalHeight){                            //Copy artwork, cutpath (if needed) and artboard reference into new document                            nestedArtwork = artwork.artGroup.duplicate( targetLayerOne );                            if(printSettings.zundCut == true) nestedCutPath = artwork.cutPath.duplicate( targetThruCut );                            nestedArtboard = artwork.artboardPath.duplicate( targetLayerOne );                            //Move artwork, cutpath (if needed) and artboard reference into position as determined by the insertion point of the current row                            //.position array is [left, top], *offset arrays are [top, left] - I know, I know, and I'm sorry                            if(rows[z] == [0, 0]) { nestedArtwork.position = [                                (rows[z][0] - artWidth) + overallOffset[0],                                (rows[z][1] + artHeight) - overallOffset[1]                            ];                            //After artwork for first item is placed, offset all other items relative to the first item                            } else { nestedArtwork.position = [                                (rows[z][0] - artWidth - placementOffset[1] + artwork.artboardOffset[1]) + overallOffset[0],                                (rows[z][1] + artHeight + artwork.artboardOffset[0] - placementOffset[0]) - overallOffset[1]                            ];}                            if(printSettings.zundCut == true) nestedCutPath.position = [nestedArtwork.position[0] - artwork.cutPathOffset[1], nestedArtwork.position[1] - artwork.cutPathOffset[0]];                            nestedArtboard.position = [nestedArtwork.position[0] - artwork.artboardOffset[1], nestedArtwork.position[1] - artwork.artboardOffset[0]];                            //Add artboard reference into the artboard group                            nestedArtboard.move(artboardGroup, ElementPlacement.PLACEATEND);                            //Move the insertion point for the current row to the left of the placed file                            rows[z] = [rows[z][0] - artWidth - padding, rows[z][1]];                            //If loop is on the top row, add another row for potential files                            if (z+1==rows.length){ rows[z+1] = [0, rows[z][1] + artHeight + padding]; }                            numberNested[i] += 1;                            lineItem.quantity += 1;                            //With art placed, break out of loop so it doesn't keep adding rows forever                            break;                        //If artwork has cycled through all rows and won't fit, adjust quantity and add it to files being returned                        } else if (z+1==rows.length){                            nestingOrder[i].quantity = nestingOrder[i].quantity - numberNested[i];                            returnFiles.push(nestingOrder[i]);                            x = nestingOrder[i].quantity;                            break;                        }                    }                //On rigid material, arrange in columns, so it populates vertically                } else {                    for(var z=0; z<cols.length; z++){                        //Cycle through each row until there is one with enough space within the maximum material size                        if (artWidth + Math.abs(cols[z][0]) <= functionalWidth && artHeight + Math.abs(cols[z][1]) <= functionalHeight){                            //Copy artwork, cutpath (if needed) and artboard reference into new document                            nestedArtwork = artwork.artGroup.duplicate( targetLayerOne );                            if(printSettings.zundCut == true) nestedCutPath = artwork.cutPath.duplicate( targetThruCut );                            nestedArtboard = artwork.artboardPath.duplicate( targetLayerOne );                            //Move artwork, cutpath (if needed) and artboard reference into position as determined by the insertion point of the current row                            //.position array is [left, top], *offset arrays are [top, left] - I know, I know, and I'm sorry                            if(cols[z] == [0, 0]) { nestedArtwork.position = [                                (cols[z][0] - artWidth) + overallOffset[0],                                (cols[z][1] + artHeight) - overallOffset[1]                            ];                            //After artwork for first item is placed, offset all other items relative to the first item                            } else { nestedArtwork.position = [                                (cols[z][0] - artWidth - placementOffset[1] + artwork.artboardOffset[1]) + overallOffset[0],                                (cols[z][1] + artHeight + artwork.artboardOffset[0] - placementOffset[0]) - overallOffset[1]                            ];}                            if(printSettings.zundCut == true) nestedCutPath.position = [nestedArtwork.position[0] - artwork.cutPathOffset[1], nestedArtwork.position[1] - artwork.cutPathOffset[0]];                            nestedArtboard.position = [nestedArtwork.position[0] - artwork.artboardOffset[1], nestedArtwork.position[1] - artwork.artboardOffset[0]];                            //Add artboard reference into the artboard group                            nestedArtboard.move(artboardGroup, ElementPlacement.PLACEATEND);                            //If loop is on the last column, add another column to the left for potential files                            if (z+1==cols.length){ cols[z+1] = [cols[z][0] - artWidth - padding, cols[z][1]]; }                            //Move the insertion point for the current column to the top of the placed file                            cols[z] = [cols[z][0], cols[z][1] + artHeight + padding];                            numberNested[i] += 1;                            lineItem.quantity += 1;                            //With art placed, break out of loop so it doesn't keep adding rows forever                            break;                        //If artwork has cycled through all rows and won't fit, adjust quantity and add it to files being returned                        } else if (z+1==cols.length){                            nestingOrder[i].quantity = nestingOrder[i].quantity - numberNested[i];                            returnFiles.push(nestingOrder[i]);                            x = nestingOrder[i].quantity;                            break;                        }                    }                }            }            metaData.push(lineItem);        }        //Alert user of any files that were too large        if(failed != ""){            alert("The following file(s) were too large to be nested: \n" + failed);        }        //If at least 1 file was sucessfully nested, prep file for finishing functions        if(numberNested.length > 0){            //Center artboard and all artwork within the drawing area            //First group everything on art layer and cut layer (except the artboardGroup)            var printGroup = groupArtworkOnLayer( targetLayerOne, "Print Group", targetDocument );            var cutGroup = groupArtworkOnLayer( targetThruCut, "Cut Group", targetDocument );            artboardGroup.move(targetLayerOne, ElementPlacement.PLACEATEND);            //Determine offsets            var printGroupOffsetLeft = printGroup.left - artboardGroup.left;            var printGroupOffsetTop = printGroup.top - artboardGroup.top;            var cutGroupOffsetLeft = cutGroup.left - artboardGroup.left;            var cutGroupOffsetTop = cutGroup.top - artboardGroup.top;            //Center artboard            artboardGroup.left = artboardGroup.width/-2;            artboardGroup.top = artboardGroup.height/2;            //Set artboard to size of artwork            artboardGroup.selected = true;            targetDocument.fitArtboardToSelectedArt(0);            artboardGroup.remove();            //Move artwork and cut groups to new artboard location, relative to their offsets            printGroup.left = targetDocument.artboards[0].artboardRect[0] + printGroupOffsetLeft;            printGroup.top = targetDocument.artboards[0].artboardRect[1] + printGroupOffsetTop;            cutGroup.left = targetDocument.artboards[0].artboardRect[0] + cutGroupOffsetLeft;            cutGroup.top = targetDocument.artboards[0].artboardRect[1] + cutGroupOffsetTop;            //Determine regmark spacing based on number of rows or columns            //Currently having user do this            /*var reg;            if(rows.length > 1) {                reg = Math.round((targetDocument.height / (rows.length - 1)) / inchScalePixels);                if (reg < 36) printSettings.regMarkSpacing = reg;            }            if(cols.length > 1) {                reg = Math.round((targetDocument.width / (cols.length - 1)) / inchScalePixels);                if (reg < 36) printSettings.regMarkSpacing = reg;            }*/            numberNested = [];            return returnFiles;        } else { return null; }    }    //----- ERROR HANDLING -----//    //Make sure Print.ai preset is present    try {        if (!app.startupPresetsList.some(function(e){return e == "Print"})) throw "\'Print.ai\' preset not found.";    }    catch(err) {        alert(err, "Error", true);        return;    }    //----- VARIABLE DECLARATION -----//    var printDocument, printArtboard, printLayerOne, printThruCut;    var nestingFiles = [], printFile = [];    var nestingDocument, nestingArtboard, nestingLayerOne, nestingThruCut;    //Scale    var inchScalePixels = printSettings.scale;    //Info to send to XMPMeta object    var metaData = [], jobLabel, otherLines = "";    //Create XMPMeta object to add metadata to file    var xmpTarget;    //----- DO STUFF -----//    //Cycle through all files, separating nested from non-nesting files    for(var x=0; x<fileObjects.length; x++){        //If the current file is not being nested, send through nesting function all by its lonesome        if(fileObjects[x].nesting == false){            //nestArtwork function requires an array, place art info into one            printFile.push(fileObjects[x]);            //Create a new document for each un-nested file            while(printFile != null && printFile.length > 0){                printDocument = app.documents.addDocument("Print");                //Assign XMPMeta object to add metadata to file                xmpTarget = new XMPMeta(printDocument.XMPString);                //Nest artwork into new document                printFile = nestArtwork( printDocument, printFile, printSettings );                if(printFile != null){                    //Create regmarks and job layer, save out                    if(printSettings.zundCut == true){                        placeRegMarks( printDocument, printSettings );                        createJobLayer( fileObjects[x].name, printDocument, printSettings );                    }                    if(printSettings.perimStroke) createPerimeterStroke( printDocument, printSettings );                    //Add metatags                    xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentHeight", Math.round((printDocument.height/72) * 100) / 100);                    xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentWidth", Math.round((printDocument.width/72) * 100) / 100);                    xmpTarget.setProperty(XMPConst.NS_XMP, "LineItem", metaData[0].name);                    xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", metaData[0].quantity);                    xmpTarget.setProperty(XMPConst.NS_XMP, "OtherLineItems", " ");                    xmpTarget.setProperty(XMPConst.NS_XMP, "Scale", inchScalePixels);                    xmpTarget.setProperty(XMPConst.NS_XMP, "CreatedBy", "Nathan Beck");                    printDocument.XMPString = xmpTarget.serialize(XMPConst.SERIALIZE_USE_COMPACT_FORMAT);                    if(printSettings.save) fileObjects[x].saveOut( printDocument, printSettings );                }                //If printFile returned null because nothing was nested, close                if(printFile == null && printSettings.closeSource) printDocument.close(SaveOptions.DONOTSAVECHANGES);            }            //Empty printFile array            printFile = [];        } else if(fileObjects[x].nesting == true){            //Extract files to be nested            nestingFiles.push(fileObjects[x]);        }    }    //Nest files together    while (nestingFiles != null && nestingFiles.length > 0){        //Set file name and save location to first element in nestingFiles (organize this later)        var nestingJobName = nestingFiles[0].name;        var nestingJobPath = nestingFiles[0].path;        //Bind LineItem's saveOut function to name and path determined above        var nestSave = nestingFiles[0].saveOut.bind( nestingFiles[0] );        //Create new document for nesting        nestingDocument = app.documents.addDocument("Print");        //Assign XMPMeta object to add metadata to file        xmpTarget = new XMPMeta(nestingDocument.XMPString);        //Nest!        nestingFiles = nestArtwork( nestingDocument, nestingFiles, printSettings );        //Once all files have been nested, add regmarks and job layer, save out        if(nestingFiles != null){            //Determine lowest line item number for job label            jobLabel = metaData.reduce( function(a,b) {                return (Number(a.name.split("-")[1].match(/\d/)) < Number(b.name.split("-")[1].match(/\d/)) ? a : b);            }).name;            //List other line items in file            for(var m=0;m<metaData.length;m++){                if (metaData[m].name != jobLabel) otherLines += "-" + metaData[m].name.split("-")[1] + " ";            }            if(printSettings.zundCut == true){                //Place RegMarks and Job# layers                placeRegMarks( nestingDocument, printSettings );                createJobLayer( jobLabel, nestingDocument, printSettings );            }            if(printSettings.perimStroke) createPerimeterStroke( nestingDocument, printSettings );            //Add metatags            xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentHeight", Math.round((nestingDocument.height/72) * 100) / 100);            xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentWidth", Math.round((nestingDocument.width/72) * 100) / 100);            xmpTarget.setProperty(XMPConst.NS_XMP, "LineItem", jobLabel);            if (metaData.length > 1){                xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", 1);            } else {                xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", metaData[0].quantity);            }            xmpTarget.setProperty(XMPConst.NS_XMP, "OtherLineItems", otherLines);            xmpTarget.setProperty(XMPConst.NS_XMP, "Scale", inchScalePixels);            xmpTarget.setProperty(XMPConst.NS_XMP, "CreatedBy", "Nathan Beck");            nestingDocument.XMPString = xmpTarget.serialize(XMPConst.SERIALIZE_USE_COMPACT_FORMAT);            if(printSettings.save) nestSave( nestingDocument, printSettings );        }    }    //If nestArtwork returned null because nothing was nested, close    if(nestingFiles == null) nestingDocument.close(SaveOptions.DONOTSAVECHANGES);    //Close all source files    if(printSettings.closeSource){        for(var z=fileObjects.length-1; z>=0; z--){            for(var n = app.documents.length-1; n>=0; n--) {                if(app.documents[n].name == fileObjects[z].path.name) app.documents[n].close(SaveOptions.DONOTSAVECHANGES);            }        }    }}//Place all artwork on a specified layer into a groupfunction groupArtworkOnLayer( layer, groupName, targetDocument ){    //Remove hidden items, unlock locked items    for (var i=layer.pageItems.length-1; i>=0; i--){        layer.pageItems[i].locked = false;        if (layer.pageItems[i].hidden == true){            layer.pageItems[i].remove();        }    }    //Remove guides    for (var x=layer.pathItems.length-1; x>=0; x--){        if (layer.pathItems[x].guides == true){            layer.pathItems[x].remove();        }    }    //Select all artwork on selected layer    layer.hasSelectedArtwork = true;    var activeSelection = targetDocument.selection;    //Create a group for the selected artwork to go into    var artwork = layer.groupItems.add();    artwork.name = groupName;    //Move selected art into group on layer and then deselect it    for (var z=0; z < activeSelection.length; z++){        activeSelection[z].move(artwork, ElementPlacement.PLACEATEND);        activeSelection[z].selected = false;    }    layer.hasSelectedArtwork = false;    return artwork;}//Function strips extension, path directory & _* from the document name//This is like the most useful function I've made so farfunction stripExtension( docName ){    var fileName = docName.toString();    var pos = fileName.lastIndexOf(".");    var slashpos = fileName.lastIndexOf("/");    var scorepos = fileName.lastIndexOf("_");    if(pos != -1){ fileName = fileName.substring(pos, -1); }    if(slashpos != -1){ fileName = fileName.substring(slashpos+1); }    if(scorepos != -1){ fileName = fileName.substring(scorepos, -1); }    return fileName;}